name: 'Run Tests'
description: 'Run tests in a package repository and record results'
inputs:
  package-path:
    description: 'Path to the package directory containing .venv'
    required: true
  package-name:
    description: 'Name of the package being tested'
    required: true
  test-type:
    description: 'Type of test run (original or patched)'
    required: true
  timeout:
    description: 'Timeout in minutes for test execution (0 = no timeout)'
    required: false
    default: '90'
  stall-timeout:
    description: 'Stall timeout in minutes - kill if no output changes (0 = disabled)'
    required: false
    default: '5'
  verbose-pytest:
    description: 'Run pytest with verbose output (-vv -s)'
    required: false
    default: 'false'
outputs:
  conclusion:
    description: 'Test conclusion (success or failure)'
    value: ${{ steps.run-tests.outputs.conclusion }}
runs:
  using: 'composite'
  steps:
    - name: Run tests on ${{ inputs.test-type }} package
      id: run-tests
      shell: bash
      run: |
        echo "SO_FAR_OK=0" >> $GITHUB_ENV
        cd ${{ inputs.package-path }}
        source .venv/bin/activate

        # Create artifacts directory
        mkdir -p ../artifacts

        TIMEOUT=${{ inputs.timeout }}
        STALL_TIMEOUT=${{ inputs.stall-timeout }}
        TIMEOUT_TRIGGERED=0
        STALL_TRIGGERED=0
        OUTPUT_FILE="../artifacts/test-output-${{ inputs.test-type }}.txt"
        OUTPUT_FILE_NO_WARNINGS="../artifacts/test-output-no-warnings-${{ inputs.test-type }}.txt"

        # Modify run-tests.sh for verbose pytest if requested
        if [ "${{ inputs.verbose-pytest }}" = "true" ]; then
          if [ -f run-tests.sh ]; then
            echo "Enabling verbose pytest output (-vv -s)"
            sed -i 's/^python -m pytest/python -m pytest -vv -s --showlocals /g' run-tests.sh
          fi
        fi

        # Add json report
        sed -i "s#^python -m pytest#python -m pytest --junit-xml=../artifacts/test-report-${{ inputs.test-type }}.xml #g" run-tests.sh

        # Remove docs Tests - lines starting with the following - we do not need them for python tests
        # python -m check_manifest
        # python -m sphinx.cmd.build
        sed -i '/^python -m check_manifest/d' run-tests.sh
        sed -i '/^python -m sphinx.cmd.build/d' run-tests.sh


        # Start stall detection watchdog in background if enabled
        if [ "$STALL_TIMEOUT" -gt 0 ]; then
          (
            STALL_CHECK_INTERVAL=$((STALL_TIMEOUT * 60))
            PREVIOUS_MD5=""
            
            while true; do
              sleep "$STALL_CHECK_INTERVAL"
              
              # Check if output file exists
              if [ ! -f "$OUTPUT_FILE" ]; then
                continue
              fi
              
              # Calculate current MD5 of output file
              CURRENT_MD5=$(md5sum "$OUTPUT_FILE" 2>/dev/null | cut -d' ' -f1)
              
              # If we have a previous MD5 and it hasn't changed, tests are stalled
              if [ -n "$PREVIOUS_MD5" ] && [ "$CURRENT_MD5" = "$PREVIOUS_MD5" ]; then
                echo ""
                echo "ðŸ”´ Test output has not changed in the last ${STALL_TIMEOUT} minutes"
                echo "ðŸ”´ Tests appear to be stalled - terminating..."
                # Kill all python processes
                killall -9 python || true
                killall -9 python3 || true
                # Create a marker file to indicate stall
                touch ../artifacts/stall-triggered-${{ inputs.test-type }}.marker
                break
              fi
              
              PREVIOUS_MD5="$CURRENT_MD5"
            done
          ) &
          STALL_WATCHDOG_PID=$!
          echo "Started stall watchdog (PID: $STALL_WATCHDOG_PID) with ${STALL_TIMEOUT}m check interval"
        fi

        # Start timeout watchdog in background if timeout is set
        if [ "$TIMEOUT" -gt 0 ]; then
          (
            TIMEOUT_SECONDS=$((TIMEOUT * 60))
            sleep "$TIMEOUT_SECONDS"
            echo ""
            echo "â±ï¸  Test execution exceeded timeout of ${TIMEOUT} minutes"
            echo "ðŸ”´ Killing all Python processes..."
            # Kill all python processes
            killall -9 python || true
            killall -9 python3 || true
            # Create a marker file to indicate timeout
            touch ../artifacts/timeout-triggered-${{ inputs.test-type }}.marker
          ) &
          WATCHDOG_PID=$!
          echo "Started timeout watchdog (PID: $WATCHDOG_PID) with ${TIMEOUT}m timeout"
        fi

        echo "ðŸ§ª Running tests on ${{ inputs.test-type }} package"
        echo "::group::Test execution (${{ inputs.test-type }})"
        set +e
        bash run-tests.sh 2>&1 | tee "$OUTPUT_FILE"
        TEST_EXIT_CODE=${PIPESTATUS[0]}
        set -e
        echo "::endgroup::"

        # Kill the stall watchdog if it's still running
        if [ "$STALL_TIMEOUT" -gt 0 ] && [ -n "$STALL_WATCHDOG_PID" ]; then
          if kill -0 "$STALL_WATCHDOG_PID" 2>/dev/null; then
            kill "$STALL_WATCHDOG_PID" 2>/dev/null || true
            echo "âœ“ Stopped stall watchdog"
          fi
        fi

        # Kill the timeout watchdog if it's still running
        if [ "$TIMEOUT" -gt 0 ] && [ -n "$WATCHDOG_PID" ]; then
          if kill -0 "$WATCHDOG_PID" 2>/dev/null; then
            kill "$WATCHDOG_PID" 2>/dev/null || true
            echo "âœ“ Stopped timeout watchdog"
          fi
        fi

        # Check if stall was triggered
        if [ -f ../artifacts/stall-triggered-${{ inputs.test-type }}.marker ]; then
          STALL_TRIGGERED=1
          rm ../artifacts/stall-triggered-${{ inputs.test-type }}.marker
          echo "" >> "$OUTPUT_FILE"
          echo "========================================" >> "$OUTPUT_FILE"
          echo "ðŸ”´ STALL DETECTED: Test output has not changed in ${STALL_TIMEOUT} minutes" >> "$OUTPUT_FILE"
          echo "ðŸ”´ Tests appear to be stuck or deadlocked" >> "$OUTPUT_FILE"
          echo "ðŸ”´ All Python processes were terminated" >> "$OUTPUT_FILE"
          echo "========================================" >> "$OUTPUT_FILE"
        fi

        # Check if timeout was triggered
        if [ -f ../artifacts/timeout-triggered-${{ inputs.test-type }}.marker ]; then
          TIMEOUT_TRIGGERED=1
          rm ../artifacts/timeout-triggered-${{ inputs.test-type }}.marker
          echo "" >> "$OUTPUT_FILE"
          echo "========================================" >> "$OUTPUT_FILE"
          echo "â±ï¸  TIMEOUT: Test execution exceeded ${TIMEOUT} minutes" >> "$OUTPUT_FILE"
          echo "ðŸ”´ All Python processes were terminated" >> "$OUTPUT_FILE"
          echo "========================================" >> "$OUTPUT_FILE"
        fi

        # create $OUTPUT_FILE_NO_WARNINGS by removing warning lines from OUTPUT_FILE
        if [ -f "$OUTPUT_FILE" ]; then
          echo "Creating filtered output without warnings..."
          
          # Start with the original file
          cp "$OUTPUT_FILE" "$OUTPUT_FILE_NO_WARNINGS"
          
          # Remove GitHub Actions warning annotations
          sed -i '/^::warning file=/d' "$OUTPUT_FILE_NO_WARNINGS"
          
          # Remove Python deprecation and warning messages
          # Match various warning patterns:
          # - DeprecationWarning, PendingDeprecationWarning, FutureWarning, etc.
          # - Lines that show where warnings come from (file paths with line numbers)
          sed -i -E '/DeprecationWarning|PendingDeprecationWarning|ResourceWarning|UserWarning|FutureWarning|ImportWarning|RuntimeWarning/d' "$OUTPUT_FILE_NO_WARNINGS"
          
          # Remove pytest warning summary lines like:
          # "-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html"
          # "warnings summary"
          # ".venv/lib/python3.12/site-packages/_pytest/assertion/rewrite.py:928: 30 warnings"
          sed -i -E '/^[[:space:]]*warnings summary/d' "$OUTPUT_FILE_NO_WARNINGS"
          sed -i -E '/^[[:space:]]*--.*warnings/d' "$OUTPUT_FILE_NO_WARNINGS"
          sed -i -E '/[0-9]+ warnings?$/d' "$OUTPUT_FILE_NO_WARNINGS"
          
          # Remove Docker pull output lines (image pulls, waiting, downloading, etc.)
          # Match patterns like: "91d2729fa4d5 Waiting", "710e142705f8 Pulling fs layer"
          # "44fc29a25beb Downloading [====>    ]  935B/1.105kB"
          sed -i -E '/^[[:space:]]*[0-9a-f]{12}[[:space:]]+(Waiting|Pulling|Downloading|Verifying|Download|Extracting|Pull complete)/d' "$OUTPUT_FILE_NO_WARNINGS"
          
          # Remove warning separator lines
          sed -i -E '/^[=\-]{10,}$/d' "$OUTPUT_FILE_NO_WARNINGS"
          
          # Remove empty lines that might be left after warning removal
          # But keep at least single empty lines for readability
          sed -i '/^$/N;/^\n$/D' "$OUTPUT_FILE_NO_WARNINGS"
          
          echo "âœ“ Created filtered output without warnings"
        fi

        if [ $TEST_EXIT_CODE -ne 0 ] || [ $TIMEOUT_TRIGGERED -eq 1 ] || [ $STALL_TRIGGERED -eq 1 ]; then
          if [ $STALL_TRIGGERED -eq 1 ]; then
            echo "âŒ Tests failed due to stall (no output change in ${STALL_TIMEOUT}m)"
          elif [ $TIMEOUT_TRIGGERED -eq 1 ]; then
            echo "âŒ Tests failed due to timeout (${TIMEOUT}m)"
          else
            echo "âŒ Tests failed (exit code: $TEST_EXIT_CODE)"
          fi
          echo "failed" > ../artifacts/test-status-${{ inputs.test-type }}.txt
          echo "conclusion=failure" >> $GITHUB_OUTPUT
        else
          echo "âœ“ Tests passed"
          echo "success" > ../artifacts/test-status-${{ inputs.test-type }}.txt
          echo "conclusion=success" >> $GITHUB_OUTPUT
        fi
        echo "SO_FAR_OK=1" >> $GITHUB_ENV

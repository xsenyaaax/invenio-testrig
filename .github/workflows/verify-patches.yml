name: Verify Invenio Patches

on:
  push: {}
  workflow_dispatch: {}

env:
  PYTHONUNBUFFERED: 1
  PYTHON_VERSION: "3.12"
  EXTRAS: "tests,opensearch2,s3,devs,s3fs,oaipmh,rdf,sparql,postgresql,admin,docs"

jobs:
  setup-docker-cache:
    name: Setup Docker Cache
    runs-on: ubuntu-latest
    steps:
      - name: Checkout verification repository
        uses: actions/checkout@v4

      - name: Setup Docker cache.
        uses: ScribeMD/docker-cache@0.5.0
        with:
          key: docker-${{ runner.os }}-invenio-bug-verification

      - name: Setup Python and UV
        uses: ./.github/actions/install-python
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Run docker services cli to initialize packages
        run: |
          uv venv --python ${{ env.PYTHON_VERSION }} --seed .venv
          source .venv/bin/activate
          uv pip install docker-services-cli setuptools
          docker-services-cli up --db postgresql --search opensearch --mq rabbitmq --cache redis --s3 minio
          docker-services-cli down
          echo "Docker cache setup completed."

  extract-tested-packages:
    name: Extract Invenio Packages
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.extract.outputs.packages }}

    steps:
      - name: Checkout verification repository
        uses: actions/checkout@v4

      - name: Clone Zenodo RDM repository
        run: |
          echo "::group::Cloning zenodo-rdm repository"
          git clone --depth 1 https://github.com/zenodo/zenodo-rdm.git
          echo "::endgroup::"
          echo "‚úì zenodo-rdm repository cloned"

      - name: Extract Invenio packages from uv.lock
        id: extract
        run: |
          # Use extract_packages_to_test.py to extract packages
          python3 scripts/extract_packages_to_test.py zenodo-rdm/uv.lock config.json packages.sh

          # Source the output variables
          source packages.sh

          # packages is already a JSON array
          echo "Found packages: $packages"
          echo "packages=$packages" >> $GITHUB_OUTPUT

  test-packages:
    name: Test ${{ matrix.package }}
    needs:
      - extract-tested-packages
      - setup-docker-cache
    runs-on: ubuntu-latest
    env:
      SO_FAR_OK: 1
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.extract-tested-packages.outputs.packages) }}

    steps:
      - name: Checkout verification repository
        uses: actions/checkout@v4

      - name: Setup Python and UV
        uses: ./.github/actions/install-python
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Load cached docker images.
        uses: ScribeMD/docker-cache@0.5.0
        with:
          key: docker-${{ runner.os }}-invenio-bug-verification

      - name: Check if sources of ${{ matrix.package }} are patched
        # determine if there is a patch for the current package
        # outputs:
        #   has_patch (true if the current package's sources are patched)
        #   original_repository_url
        #   original_repository_branch (currently always empty as default branch is used)
        #   patched_repository_url (equal to original_repository_url if not patched, otherwise the patch URL)
        #   patched_repository_branch (equal to original_repository_branch if not patched, otherwise the patch branch)
        id: load-patches
        run: |

          # Use lookup_package.py to get repository information
          eval $(python3 scripts/lookup_package.py config.json patches.json ${{ matrix.package }})

          # Set outputs
          echo "original_repository_url=$original_repository_url" >> $GITHUB_OUTPUT
          echo "original_repository_branch=$original_repository_branch" >> $GITHUB_OUTPUT

          # Determine if patch exists
          if [ -n "$patched_repository_url" ]; then
            echo "has_patch=true" >> $GITHUB_OUTPUT
            echo "patched_repository_url=$patched_repository_url" >> $GITHUB_OUTPUT
            echo "patched_repository_branch=$patched_repository_branch" >> $GITHUB_OUTPUT
            echo "Found patch for ${{ matrix.package }}: $patched_repository_url @ $patched_repository_branch"
          else
            echo "has_patch=false" >> $GITHUB_OUTPUT
            echo "patched_repository_url=$original_repository_url" >> $GITHUB_OUTPUT
            echo "patched_repository_branch=$original_repository_branch" >> $GITHUB_OUTPUT
            echo "No patch configured for ${{ matrix.package }}"
          fi

      # we start by cloning the package (possibly patched) to run tests on patch at first
      - name: Clone package repository for patched (possibly) package tests
        continue-on-error: true
        uses: ./.github/actions/clone-package
        with:
          repository-url: ${{ steps.load-patches.outputs.patched_repository_url }}
          repository-branch: ${{ steps.load-patches.outputs.patched_repository_branch }}
          destination: package-repo

      - name: Setup virtual environment and install dependencies
        if: env.SO_FAR_OK == '1'
        continue-on-error: true
        uses: ./.github/actions/setup-venv
        with:
          package-path: package-repo
          extras: ${{ env.EXTRAS }}
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Dump original requirements
        if: env.SO_FAR_OK == '1' && ( steps.load-patches.outputs.has_patch == 'false' )
        uses: ./.github/actions/dump-requirements
        with:
          package-path: package-repo
          requirement-type: original

      - name: Dump requirements of original package with sources patched
        if: env.SO_FAR_OK == '1' && ( steps.load-patches.outputs.has_patch == 'true' )
        uses: ./.github/actions/dump-requirements
        with:
          package-path: package-repo
          requirement-type: patched

      - name: Apply patches if applicable
        id: check-patch
        continue-on-error: true
        if: env.SO_FAR_OK == '1'
        run: |

          # Use apply_patches.py to check and apply patches
          python3 scripts/apply_patches.py ${{ matrix.package }} package-repo/.venv patches.json patch-variables.sh

          # Source the output variables
          source patch-variables.sh

          # Set outputs
          echo "applies=$applies" >> $GITHUB_OUTPUT
          echo "patched_packages=$patched_packages" >> $GITHUB_OUTPUT

          if [ "$applies" = "true" ]; then
            echo "üîÑ Patches were applied to: $patched_packages"
          else
            echo "‚ÑπÔ∏è  No applicable patches found for this package"
            echo "reason=no-patch-packages-installed" >> $GITHUB_OUTPUT
          fi

      - name: Dump requirements for package with patched dependencies
        if: env.SO_FAR_OK == '1' && ( steps.check-patch.outputs.applies == 'true' )
        uses: ./.github/actions/dump-requirements
        with:
          package-path: package-repo
          requirement-type: patched-dependencies

      - name: Run tests on patched package / with patched dependencies
        id: test-with-patch
        continue-on-error: true
        if: env.SO_FAR_OK == '1' && ( steps.check-patch.outputs.applies == 'true' || steps.load-patches.outputs.has_patch == 'true' )
        uses: ./.github/actions/run-tests
        with:
          package-path: package-repo
          package-name: ${{ matrix.package }}
          test-type: patched

      # if the previous step failed, we will try to run the tests without patches
      - name: Clone package repository for tests without patches
        continue-on-error: true
        if: env.SO_FAR_OK == '1' && steps.test-with-patch.outputs.conclusion == 'failure'
        uses: ./.github/actions/clone-package
        with:
          repository-url: ${{ steps.load-patches.outputs.original_repository_url }}
          repository-branch: ${{ steps.load-patches.outputs.original_repository_branch }}
          destination: package-repo

      - name: Setup virtual environment and install dependencies for original package tests
        if: env.SO_FAR_OK == '1' && steps.test-with-patch.outputs.conclusion == 'failure'
        continue-on-error: true
        uses: ./.github/actions/setup-venv
        with:
          package-path: package-repo
          extras: ${{ env.EXTRAS }}
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Run tests on original package without patches
        id: test-without-patch
        continue-on-error: true
        if: env.SO_FAR_OK == '1' && steps.test-with-patch.outputs.conclusion == 'failure'
        uses: ./.github/actions/run-tests
        with:
          package-path: package-repo
          package-name: ${{ matrix.package }}
          test-type: original

      - name: Compare test results
        if: env.SO_FAR_OK == '1'
        id: compare
        continue-on-error: true
        run: |
          # Create a diff of the test outputs
          if [ -f artifacts/test-output-original.txt ] && [ -f test-output-patched.txt ] ; then
            diff -buN artifacts/test-output-original.txt test-output-patched.txt > artifacts/test-diff.txt
          fi

          # Analyze the results using status files
          ORIGINAL_TESTS_OUTCOME=$(cat artifacts/test-status-original.txt 2>/dev/null || echo "skipped")
          PATCHED_TESTS_OUTCOME=$(cat artifacts/test-status-patched.txt 2>/dev/null|| echo "skipped")

          if [ "$ORIGINAL_TESTS_OUTCOME" == "failed" ] ; then
            if [ "$PATCHED_TESTS_OUTCOME" == "failed" ] ; then
              RESULT="still-failing"
              RESULT_ICON="‚ö†Ô∏è"
              RESULT_TEXT="Tests still failing after patch"
            elif [ "$PATCHED_TESTS_OUTCOME" == "success" ] ; then
              RESULT="fixed"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Patch fixed failing tests"
            elif [ "$PATCHED_TESTS_OUTCOME" == "skipped" ] ; then
              RESULT="still-failing-skipped"
              RESULT_ICON="‚ö†Ô∏è"
              RESULT_TEXT="Tests failing in original, patched tests skipped"
            fi
          elif [ "$ORIGINAL_TESTS_OUTCOME" == "success" ] ; then
            if [ "$PATCHED_TESTS_OUTCOME" == "failed" ] ; then
              RESULT="regression"
              RESULT_ICON="‚ùå"
              RESULT_TEXT="Patch introduced test failures"
            elif [ "$PATCHED_TESTS_OUTCOME" == "success" ] ; then
              RESULT="ok"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Patch successfully applied, tests passed"
            elif [ "$PATCHED_TESTS_OUTCOME" == "skipped" ] ; then
              RESULT="no-change-skipped"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Tests passed before patch, skipped patch tests"
            fi
          elif [ "$ORIGINAL_TESTS_OUTCOME" == "skipped" ] ; then
            if [ "$PATCHED_TESTS_OUTCOME" == "failed" ] ; then
              RESULT="regression-skipped"
              RESULT_ICON="‚ùå"
              RESULT_TEXT="Patch introduced test failures"
            elif [ "$PATCHED_TESTS_OUTCOME" == "success" ] ; then
              RESULT="fixed-skipped"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Patch applied successfully, tests passed"
            elif [ "$PATCHED_TESTS_OUTCOME" == "skipped" ] ; then
              RESULT="no-change-both-skipped"
              RESULT_ICON="‚ÑπÔ∏è"
              RESULT_TEXT="Tests skipped before and after patch"
            fi
          fi

          echo "$RESULT_ICON $RESULT_TEXT"

          echo "result=$RESULT" >> $GITHUB_OUTPUT
          echo "result_icon=$RESULT_ICON" >> $GITHUB_OUTPUT
          echo "result_text=$RESULT_TEXT" >> $GITHUB_OUTPUT
          echo "ORIGINAL_TESTS_OUTCOME=$ORIGINAL_TESTS_OUTCOME" >> $GITHUB_OUTPUT
          echo "PATCHED_TESTS_OUTCOME=$PATCHED_TESTS_OUTCOME" >> $GITHUB_OUTPUT

      - name: Create result summary
        id: summary
        continue-on-error: true
        run: |
          ORIGINAL_TESTS_OUTCOME=$(cat artifacts/test-status-original.txt 2>/dev/null || echo "skipped")
          PATCHED_TESTS_OUTCOME=$(cat artifacts/test-status-patched.txt 2>/dev/null|| echo "skipped")

          if [ -z "${{ steps.check-patch.outputs.applies }}" ] ; then
            APPLIES="false"
          else
            APPLIES="${{ steps.check-patch.outputs.applies }}"
          fi

          cat > artifacts/result-summary.json << EOF
          {
            "package": "${{ matrix.package }}",
            "has_patch": ${{ steps.load-patches.outputs.has_patch }},
            "patch_applies": $APPLIES,
            "original_tests_outcome": "$ORIGINAL_TESTS_OUTCOME",
            "patched_tests_outcome": "$PATCHED_TESTS_OUTCOME",
            "result": "${{ steps.compare.outputs.result }}",
            "result_icon": "${{ steps.compare.outputs.result_icon }}",
            "result_text": "${{ steps.compare.outputs.result_text }}",
            "patched_packages": "${{ steps.check-patch.outputs.patched_packages }}"
          }
          EOF

          cat artifacts/result-summary.json

      - name: Extract warnings from test logs
        if: always()
        run: |
          # Extract warnings from original test log if it exists
          if [ -f artifacts/test-output-original.txt ]; then
            python3 scripts/extract_warnings.py artifacts/test-output-original.txt original artifacts/result-summary.json
          fi

          # Extract warnings from patched test log if it exists
          if [ -f artifacts/test-output-patched.txt ]; then
            python3 scripts/extract_warnings.py artifacts/test-output-patched.txt patched artifacts/result-summary.json
          fi

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.package }}
          path: |
            artifacts/
          retention-days: 30

      - name: Fail job if any tests failed
        if: always()
        run: |
          ORIGINAL_TESTS_OUTCOME=$(cat artifacts/test-status-original.txt 2>/dev/null || echo "skipped")
          PATCHED_TESTS_OUTCOME=$(cat artifacts/test-status-patched.txt 2>/dev/null|| echo "skipped")

          if [ "$PATCHED_TESTS_OUTCOME" = "failed" ] ; then
            echo "Error: Tests for patched package ${{ matrix.package }} failed"
            exit 1
          elif [ "$ORIGINAL_TESTS_OUTCOME" = "failed" ] ; then
            echo "Error: Tests for original package ${{ matrix.package }} failed"
            exit 1
          fi

  generate-report:
    name: Generate Summary Report
    needs: test-packages
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create report directory
        run: |
          REPORT_DIR=reports/$(date +%Y-%m-%d_%H-%M-%S)
          mkdir -p "$REPORT_DIR"
          echo "Report directory created at $REPORT_DIR"
          echo "REPORT_DIR=$REPORT_DIR" >> $GITHUB_ENV

      - name: Generate summary report
        run: |
          # Generate README.md with summary
          echo "# Invenio Bugfix Verification Results" > ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md
          echo "_Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")_" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md

          # Calculate overall statistics
          TOTAL=0
          PATCHED=0
          UNPATCHED=0
          FIXED=0
          REGRESSION=0
          NO_CHANGE=0
          STILL_FAILING=0
          SUCCESS_ORIGINAL=0
          FAILED_ORIGINAL=0
          SUCCESS_PATCHED=0
          FAILED_PATCHED=0

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              TOTAL=$((TOTAL + 1))
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")

              if [ "$APPLIES" = "true" ]; then
                PATCHED=$((PATCHED + 1))
                RESULT=$(jq -r '.result' "$dir/result-summary.json")
                case $RESULT in
                  fixed) FIXED=$((FIXED + 1)) ;;
                  regression) REGRESSION=$((REGRESSION + 1)) ;;
                  still-failing) STILL_FAILING=$((STILL_FAILING + 1)) ;;
                  *) NO_CHANGE=$((NO_CHANGE + 1)) ;;
                esac

                ORIGINAL_TESTS_OUTCOME=$(jq -r '.original_tests_outcome' "$dir/result-summary.json")
                PATCHED_TESTS_OUTCOME=$(jq -r '.patched_tests_outcome' "$dir/result-summary.json")
                [ "$ORIGINAL_TESTS_OUTCOME" = "success" ] && SUCCESS_ORIGINAL=$((SUCCESS_ORIGINAL + 1))
                [ "$ORIGINAL_TESTS_OUTCOME" = "failed" ] && FAILED_ORIGINAL=$((FAILED_ORIGINAL + 1))
                [ "$PATCHED_TESTS_OUTCOME" = "success" ] && SUCCESS_PATCHED=$((SUCCESS_PATCHED + 1))
                [ "$PATCHED_TESTS_OUTCOME" = "failed" ] && FAILED_PATCHED=$((FAILED_PATCHED + 1))
              else
                UNPATCHED=$((UNPATCHED + 1))
                ORIGINAL_TESTS_OUTCOME=$(jq -r '.original_tests_outcome' "$dir/result-summary.json")
                [ "$ORIGINAL_TESTS_OUTCOME" = "success" ] && SUCCESS_ORIGINAL=$((SUCCESS_ORIGINAL + 1))
                [ "$ORIGINAL_TESTS_OUTCOME" = "failed" ] && FAILED_ORIGINAL=$((FAILED_ORIGINAL + 1))
              fi
            fi
          done

          # Overall Status
          echo "## üìä Overall Status" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md
          echo "| Metric | Count |" >> ${REPORT_DIR}/README.md
          echo "|--------|-------|" >> ${REPORT_DIR}/README.md
          echo "| **Total Packages** | $TOTAL |" >> ${REPORT_DIR}/README.md
          echo "| **Patched Packages** | $PATCHED |" >> ${REPORT_DIR}/README.md
          echo "| **Unpatched Packages** | $UNPATCHED |" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md
          echo "### Patch Results" >> ${REPORT_DIR}/README.md
          echo "| Result | Count |" >> ${REPORT_DIR}/README.md
          echo "|--------|-------|" >> ${REPORT_DIR}/README.md
          echo "| ‚úÖ Fixed | $FIXED |" >> ${REPORT_DIR}/README.md
          echo "| ‚ùå Regressions | $REGRESSION |" >> ${REPORT_DIR}/README.md
          echo "| ‚ö†Ô∏è  Still Failing | $STILL_FAILING |" >> ${REPORT_DIR}/README.md
          echo "| ‚ÑπÔ∏è  No Change | $NO_CHANGE |" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md

          # List of patches
          echo "## üîß Configured Patches" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md

          # Extract unique patches from all result files
          PATCHES_FOUND=false
          declare -A PATCH_LIST
          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")
              if [ "$APPLIES" = "true" ]; then
                PATCHED_PKGS=$(jq -r '.patched_packages' "$dir/result-summary.json")
                if [ -n "$PATCHED_PKGS" ] && [ "$PATCHED_PKGS" != "null" ]; then
                  PATCHES_FOUND=true
                  for pkg in $PATCHED_PKGS; do
                    PATCH_LIST[$pkg]=1
                  done
                fi
              fi
            fi
          done

          # Patches from patches.json
          echo "## üîÑ Patched Packages" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md
          echo "| Package | Patches Applied | Original | Patched | Result |" >> ${REPORT_DIR}/README.md
          echo "|---------|----------------|--------|-------|--------|" >> ${REPORT_DIR}/README.md

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              HAS_PATCH=$(jq -r '.has_patch' "$dir/result-summary.json")
              if [ "$HAS_PATCH" = "true" ]; then
                PACKAGE=$(jq -r '.package' "$dir/result-summary.json")
                PATCHED_PKGS=$(jq -r '.patched_packages' "$dir/result-summary.json" | tr '\n' ' ')
                ORIGINAL_TESTS_OUTCOME=$(jq -r '.original_tests_outcome' "$dir/result-summary.json")
                PATCHED_TESTS_OUTCOME=$(jq -r '.patched_tests_outcome' "$dir/result-summary.json")
                RESULT_ICON=$(jq -r '.result_icon' "$dir/result-summary.json")
                RESULT_TEXT=$(jq -r '.result_text' "$dir/result-summary.json")

                # Create package directory and copy test outputs
                mkdir -p "${REPORT_DIR}/$PACKAGE"
                if [ -f "$dir/test-output-original.txt" ]; then
                  cp "$dir/test-output-original.txt" "${REPORT_DIR}/$PACKAGE/"
                fi
                if [ -f "$dir/test-output-patched.txt" ]; then
                  cp "$dir/test-output-patched.txt" "${REPORT_DIR}/$PACKAGE/"
                fi
                if [ -f "$dir/test-diff.txt" ]; then
                  cp "$dir/test-diff.txt" "${REPORT_DIR}/$PACKAGE/"
                fi

                # Format status
                case $ORIGINAL_TESTS_OUTCOME in
                  success) ORIGINAL_STATUS="‚úÖ Pass" ;;
                  failed) ORIGINAL_STATUS="‚ùå Fail" ;;
                  skipped) ORIGINAL_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) ORIGINAL_STATUS="‚ùì Unknown" ;;
                esac

                case $PATCHED_TESTS_OUTCOME in
                  success) PATCHED_STATUS="‚úÖ Pass" ;;
                  failed) PATCHED_STATUS="‚ùå Fail" ;;
                  skipped) PATCHED_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) PATCHED_STATUS="‚ùì Unknown" ;;
                esac

                # Use result_icon and result_text from artifacts
                if [ -n "$RESULT_ICON" ] && [ "$RESULT_ICON" != "null" ]; then
                  RESULT_STATUS="$RESULT_ICON $RESULT_TEXT"
                else
                  RESULT_STATUS="‚ùì Unknown"
                fi

                # Create links for test outputs
                LINKS=""
                if [ -f "${REPORT_DIR}/$PACKAGE/test-output-original.txt" ]; then
                  LINKS="$LINKS [original]($PACKAGE/test-output-original.txt)"
                fi
                if [ -f "${REPORT_DIR}/$PACKAGE/test-output-patched.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [patched]($PACKAGE/test-output-patched.txt)"
                fi
                if [ -f "${REPORT_DIR}/$PACKAGE/test-diff.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [diff]($PACKAGE/test-diff.txt)"
                fi

                if [ -n "$LINKS" ]; then
                  PACKAGE_DISPLAY="\`$PACKAGE\` <br/> $LINKS"
                else
                  PACKAGE_DISPLAY="\`$PACKAGE\`"
                fi

                echo "| $PACKAGE_DISPLAY | $PATCHED_PKGS | $ORIGINAL_STATUS | $PATCHED_STATUS | $RESULT_STATUS |" >> ${REPORT_DIR}/README.md
              fi
            fi
          done
          echo "" >> ${REPORT_DIR}/README.md

          # Packages that do not depend on patched packages
          echo "## üì¶ Packages that do not depend on patched packages" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md
          echo "| Package | Build Status |" >> ${REPORT_DIR}/README.md
          echo "|---------|--------------|" >> ${REPORT_DIR}/README.md

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")
              HAS_PATCH=$(jq -r '.has_patch' "$dir/result-summary.json")
              if [ "$APPLIES" != "true" ] && [ "$HAS_PATCH" != "true" ]; then
                PACKAGE=$(jq -r '.package' "$dir/result-summary.json")
                ORIGINAL_TESTS_OUTCOME=$(jq -r '.original_tests_outcome' "$dir/result-summary.json")

                # Create package directory and copy test output
                mkdir -p "${REPORT_DIR}/$PACKAGE"
                if [ -f "$dir/test-output-original.txt" ]; then
                  cp "$dir/test-output-original.txt" "${REPORT_DIR}/$PACKAGE/"
                fi

                case $ORIGINAL_TESTS_OUTCOME in
                  success) STATUS="‚úÖ Success" ;;
                  failed) STATUS="‚ùå Failed" ;;
                  skipped) STATUS="‚è≠Ô∏è  Skipped" ;;
                  *) STATUS="‚ùì Unknown" ;;
                esac

                # Create link for test output if it exists
                if [ -f "${REPORT_DIR}/$PACKAGE/test-output-original.txt" ]; then
                  PACKAGE_DISPLAY="\`$PACKAGE\` <br/> [output]($PACKAGE/test-output-original.txt)"
                else
                  PACKAGE_DISPLAY="\`$PACKAGE\`"
                fi

                echo "| $PACKAGE_DISPLAY | $STATUS |" >> ${REPORT_DIR}/README.md
              fi
            fi
          done
          echo "" >> ${REPORT_DIR}/README.md

          # newly uncommented
          # Packages that depend on patched packages
          echo "## üîÑ Packages that depend on patched packages" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md
          echo "| Package | Patches Applied | Original | Patched | Result |" >> ${REPORT_DIR}/README.md
          echo "|---------|----------------|--------|-------|--------|" >> ${REPORT_DIR}/README.md

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")
              if [ "$APPLIES" = "true" ]; then
                PACKAGE=$(jq -r '.package' "$dir/result-summary.json")
                PATCHED_PKGS=$(jq -r '.patched_packages' "$dir/result-summary.json" | tr '\n' ' ')
                ORIGINAL_TESTS_OUTCOME=$(jq -r '.original_tests_outcome' "$dir/result-summary.json")
                PATCHED_TESTS_OUTCOME=$(jq -r '.patched_tests_outcome' "$dir/result-summary.json")
                RESULT_ICON=$(jq -r '.result_icon' "$dir/result-summary.json")
                RESULT_TEXT=$(jq -r '.result_text' "$dir/result-summary.json")

                # Create package directory and copy test outputs
                mkdir -p "${REPORT_DIR}/$PACKAGE"
                if [ -f "$dir/test-output-original.txt" ]; then
                  cp "$dir/test-output-original.txt" "${REPORT_DIR}/$PACKAGE/"
                fi
                if [ -f "$dir/test-output-patched.txt" ]; then
                  cp "$dir/test-output-patched.txt" "${REPORT_DIR}/$PACKAGE/"
                fi
                if [ -f "$dir/test-diff.txt" ]; then
                  cp "$dir/test-diff.txt" "${REPORT_DIR}/$PACKAGE/"
                fi

                # Format status
                case $ORIGINAL_TESTS_OUTCOME in
                  success) ORIGINAL_STATUS="‚úÖ Pass" ;;
                  failed) ORIGINAL_STATUS="‚ùå Fail" ;;
                  skipped) ORIGINAL_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) ORIGINAL_STATUS="‚ùì Unknown" ;;
                esac

                case $PATCHED_TESTS_OUTCOME in
                  success) PATCHED_STATUS="‚úÖ Pass" ;;
                  failed) PATCHED_STATUS="‚ùå Fail" ;;
                  skipped) PATCHED_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) PATCHED_STATUS="‚ùì Unknown" ;;
                esac

                # Use result_icon and result_text from artifacts
                if [ -n "$RESULT_ICON" ] && [ "$RESULT_ICON" != "null" ]; then
                  RESULT_STATUS="$RESULT_ICON $RESULT_TEXT"
                else
                  RESULT_STATUS="‚ùì Unknown"
                fi

                # Create links for test outputs
                LINKS=""
                if [ -f "${REPORT_DIR}/$PACKAGE/test-output-original.txt" ]; then
                  LINKS="$LINKS [original]($PACKAGE/test-output-original.txt)"
                fi
                if [ -f "${REPORT_DIR}/$PACKAGE/test-output-patched.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [patched]($PACKAGE/test-output-patched.txt)"
                fi
                if [ -f "${REPORT_DIR}/$PACKAGE/test-diff.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [diff]($PACKAGE/test-diff.txt)"
                fi

                if [ -n "$LINKS" ]; then
                  PACKAGE_DISPLAY="\`$PACKAGE\` <br/> $LINKS"
                else
                  PACKAGE_DISPLAY="\`$PACKAGE\`"
                fi

                echo "| $PACKAGE_DISPLAY | $PATCHED_PKGS | $ORIGINAL_STATUS | $PATCHED_STATUS | $RESULT_STATUS |" >> ${REPORT_DIR}/README.md
              fi
            fi
          done
          echo "" >> ${REPORT_DIR}/README.md

          echo "---" >> ${REPORT_DIR}/README.md
          echo "" >> ${REPORT_DIR}/README.md
          echo "_For detailed test outputs and diffs, see the [full report](https://mesemus.github.io/invenio-bug-verification/)._" >> ${REPORT_DIR}/README.md

          cat ${REPORT_DIR}/README.md

      - name: Upload the report dir as artifact
        uses: actions/upload-artifact@v4
        with:
          name: verification-report
          path: ${REPORT_DIR}/
          retention-days: 90

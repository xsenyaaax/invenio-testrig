name: Verify Invenio Patches

on:
  push: {}
  workflow_dispatch: {}

env:
  PYTHONUNBUFFERED: 1
  PYTHON_VERSION: "3.13"

jobs:
  extract-packages:
    name: Extract Invenio Packages
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.extract.outputs.packages }}

    steps:
      - name: Checkout verification repository
        uses: actions/checkout@v4

      - name: Clone Zenodo RDM repository
        run: |
          echo "::group::Cloning zenodo-rdm repository"
          git clone --depth 1 https://github.com/zenodo/zenodo-rdm.git
          echo "::endgroup::"
          echo "‚úì zenodo-rdm repository cloned"

      - name: Extract Invenio packages from uv.lock
        id: extract
        run: |
          cd zenodo-rdm

          # Extract package names starting with 'invenio-' from uv.lock
          if [ -f "uv.lock" ]; then
            PACKAGES=$(cat uv.lock | egrep '^name = "invenio-' | \
                      sed 's/name = "\(.*\)"/\1/' | \
                      sort -u)
          else
            echo "Error: uv.lock not found, using fallback list"
            exit 1
          fi

          FILTERED_PACKAGES=()
          for pkg in $PACKAGES; do
            # check if the package is in not_tested.json using jq
            IS_NOT_TESTED=$(jq --arg pkg "$pkg" 'index($pkg)' ../not_tested.json)
            if [ "$IS_NOT_TESTED" = "null" ]; then
                FILTERED_PACKAGES+=("$pkg")
            else
                echo "Skipping not tested package: $pkg"
            fi
          done

          # convert packages to JSON array
          PACKAGES=$(printf '%s\n' "${FILTERED_PACKAGES[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "Found packages: $PACKAGES"
          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT

  test-packages:
    name: Test ${{ matrix.package }}
    needs: extract-packages
    runs-on: ubuntu-latest
    env:
      SO_FAR_OK: 1
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.extract-packages.outputs.packages) }}

    steps:
      - name: Checkout verification repository
        uses: actions/checkout@v4
        with:
          path: verification-repo

      - name: Store verification repository path
        run: |
          echo "VERIFICATION_REPO_PATH=$PWD/verification-repo" >> $GITHUB_ENV

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        run: |
          echo "::group::Installing uv"
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          echo "::endgroup::"
          echo "‚úì uv installed successfully"

      - name: Install libxml2-dev
        run: |
          echo "::group::Installing system dependencies"
          sudo apt-get update
          sudo apt-get install -y libxml2-dev libxslt-dev
          echo "::endgroup::"
          echo "‚úì System dependencies installed"

      - name: Load patches configuration
        id: load-patches
        run: |
          cd ${VERIFICATION_REPO_PATH}

          echo "SO_FAR_OK=0" >> $GITHUB_ENV

          PATCH_URL=$(jq -r '.["${{ matrix.package }}"].url // empty' patches.json)
          PATCH_BRANCH=$(jq -r '.["${{ matrix.package }}"].branch // empty' patches.json)

          echo "patch_url=$PATCH_URL" >> $GITHUB_OUTPUT
          echo "patch_branch=$PATCH_BRANCH" >> $GITHUB_OUTPUT

          if [ -n "$PATCH_URL" ]; then
            echo "has_patch=true" >> $GITHUB_OUTPUT
            echo "Found patch for ${{ matrix.package }}: $PATCH_URL @ $PATCH_BRANCH"
          else
            echo "has_patch=false" >> $GITHUB_OUTPUT
            echo "No patch configured for ${{ matrix.package }}"
          fi
          echo "SO_FAR_OK=1" >> $GITHUB_ENV

      - name: Clone package repository
        if: env.SO_FAR_OK == '1'
        run: |
          echo "SO_FAR_OK=0" >> $GITHUB_ENV
          echo "üì¶ Cloning from inveniosoftware: ${{ matrix.package }}"
          echo "::group::Cloning package repository"
          git clone --depth 1 https://github.com/inveniosoftware/${{ matrix.package }}.git package-repo || {
            echo "::endgroup::"
            echo "‚ùå Failed to clone from inveniosoftware, package may not exist"
            exit 0
          }
          echo "::endgroup::"
          echo "‚úì Package cloned from inveniosoftware"
          echo "SO_FAR_OK=1" >> $GITHUB_ENV

      - name: Create virtual environment
        continue-on-error: true
        if: env.SO_FAR_OK == '1'
        run: |
          echo "SO_FAR_OK=0" >> $GITHUB_ENV
          cd package-repo
          echo "üîß Setting up virtual environment and installing dependencies"
          echo "::group::Creating virtual environment"
          uv venv --seed
          echo "::endgroup::"
          source .venv/bin/activate

          # Install the package with test dependencies
          echo "::group::Installing package with dependencies"
          uv pip install -e ".[tests,opensearch2,s3,devs,s3fs,oaipmh,rdf,sparql,postgresql,admin]"
          echo "::endgroup::"
          echo "‚úì Virtual environment created and dependencies installed"
          echo "SO_FAR_OK=1" >> $GITHUB_ENV

      - name: Run tests without patches
        id: test-without-patch
        continue-on-error: true
        if: env.SO_FAR_OK == '1'
        run: |
          echo "SO_FAR_OK=0" >> $GITHUB_ENV
          cd package-repo
          source .venv/bin/activate

          echo "üß™ Running tests without patches"
          echo "::group::Test execution (before patches)"
          set +e
          echo bash run-tests.sh 2>&1 | tee ../test-output-before.txt
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          echo "::endgroup::"

          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Tests failed (exit code: $TEST_EXIT_CODE)"
            echo "failed" > ../test-output-before-status.txt
          else
            echo "‚úì Tests passed without patches"
            echo "success" > ../test-output-before-status.txt
          fi
          echo "SO_FAR_OK=1" >> $GITHUB_ENV

      - name: Clone package repository if it is patched
        if: env.SO_FAR_OK == '1' && steps.load-patches.outputs.has_patch == 'true'
        run: |
          echo "SO_FAR_OK=0" >> $GITHUB_ENV
          echo "üì¶ Cloning from patch repository: ${{ steps.load-patches.outputs.patch_url }} @ ${{ steps.load-patches.outputs.patch_branch }}"
          echo "::group::Cloning package repository"
          git clone --depth 1 --branch ${{ steps.load-patches.outputs.patch_branch }} \
            ${{ steps.load-patches.outputs.patch_url }} package-repo
          echo "::endgroup::"
          echo "‚úì Package cloned from patch repository"
          echo "SO_FAR_OK=1" >> $GITHUB_ENV

      - name: Check if patch applies to this package
        id: check-patch
        continue-on-error: true
        if: env.SO_FAR_OK == '1' && steps.load-patches.outputs.has_patch == 'false'
        run: |
          cd verification-repo

          # Check if any package in patches.json is installed in the venv
          APPLIES=false
          PATCHED_PACKAGES=""

          cd ../package-repo
          source .venv/bin/activate

          # Get all packages from patches.json
          cd ../verification-repo
          PATCH_PACKAGES=$(jq -r 'keys[]' patches.json)

          cd ../package-repo
          echo "::group::Checking for applicable patches"
          for pkg in $PATCH_PACKAGES; do
            if pip show "$pkg" > /dev/null 2>&1; then
              APPLIES=true
              PATCHED_PACKAGES="$PATCHED_PACKAGES $pkg"
              echo "Found: $pkg is installed and will be patched"
            fi
          done
          echo "::endgroup::"

          if [ "$APPLIES" = "true" ]; then
            echo "üîÑ Patches will be applied to:$PATCHED_PACKAGES"
            echo "applies=true" >> $GITHUB_OUTPUT
            echo "patched_packages=$PATCHED_PACKAGES" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è  No applicable patches found for this package"
            echo "applies=false" >> $GITHUB_OUTPUT
            echo "reason=no-patch-packages-installed" >> $GITHUB_OUTPUT
          fi

      - name: Apply patches
        if: steps.check-patch.outputs.applies == 'true' && env.SO_FAR_OK == '1' && steps.load-patches.outputs.has_patch == 'false'
        continue-on-error: true
        run: |
          # For each package in patches.json that's installed in the venv
          for pkg in ${{ steps.check-patch.outputs.patched_packages }}; do
            PATCH_URL=$(jq -r ".\"$pkg\".url" verification-repo/patches.json)
            PATCH_BRANCH=$(jq -r ".\"$pkg\".branch" verification-repo/patches.json)

            echo "üì• Applying patch for $pkg from $PATCH_URL @ $PATCH_BRANCH"

            # Clone the patched version to a temporary directory
            echo "::group::Cloning and installing patched $pkg"
            git clone --depth 1 --branch "$PATCH_BRANCH" "$PATCH_URL" "patched-$pkg"

            # Install it in the venv
            cd package-repo
            source .venv/bin/activate
            uv pip install "../patched-$pkg" --force-reinstall --no-deps
            cd ..
            echo "::endgroup::"
            echo "‚úì Patch applied for $pkg"
          done

      - name: Run tests with patches
        if: ( steps.check-patch.outputs.applies == 'true' || steps.load-patches.outputs.has_patch == 'true' ) && env.SO_FAR_OK == '1'
        id: test-with-patch
        continue-on-error: true
        run: |
          cd package-repo
          source .venv/bin/activate

          echo "üß™ Running tests with patches applied"
          echo "::group::Test execution (after patches)"
          set +e
          echo bash run-tests.sh 2>&1 | tee ../test-output-after.txt
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          echo "::endgroup::"

          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Tests failed (exit code: $TEST_EXIT_CODE)"
            echo "failed" > ../test-output-after-status.txt
          else
            echo "‚úì Tests passed with patches"
            echo "success" > ../test-output-after-status.txt
          fi

      - name: Compare test results
        if: env.SO_FAR_OK == '1'
        id: compare
        continue-on-error: true
        run: |
          # Create a diff of the test outputs
          diff -u test-output-before.txt test-output-after.txt > test-diff.txt || true

          # Analyze the results using status files
          BEFORE_STATUS=$(cat test-output-before-status.txt || echo "skipped")
          AFTER_STATUS=$(cat test-output-after-status.txt || echo "skipped")

          if [ "$BEFORE_STATUS" == "failed" ] ; then
            if [ "$AFTER_STATUS" == "failed" ] ; then
              RESULT="still-failing"
              RESULT_ICON="‚ö†Ô∏è"
              RESULT_TEXT="Tests still failing after patch"
            elif [ "$AFTER_STATUS" == "success" ] ; then
              RESULT="fixed"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Patch fixed failing tests"
            elif [ "$AFTER_STATUS" == "skipped" ] ; then
              RESULT="still-failing-skipped"
              RESULT_ICON="‚ö†Ô∏è"
              RESULT_TEXT="Tests still failing after patch (after tests skipped)"
            fi
          elif [ "$BEFORE_STATUS" == "success" ] ; then
            if [ "$AFTER_STATUS" == "failed" ] ; then
              RESULT="regression"
              RESULT_ICON="‚ùå"              
              RESULT_TEXT="Patch introduced test failures"
            elif [ "$AFTER_STATUS" == "success" ] ; then
              RESULT="ok"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Tests passed before and after patch"
            elif [ "$AFTER_STATUS" == "skipped" ] ; then
              RESULT="no-change-skipped"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Tests passed before patch, after tests skipped"
            fi
          elif [ "$BEFORE_STATUS" == "skipped" ] ; then
            if [ "$AFTER_STATUS" == "failed" ] ; then
              RESULT="regression-skipped"
              RESULT_ICON="‚ùå"
              RESULT_TEXT="Patch introduced test failures (before tests skipped)"
            elif [ "$AFTER_STATUS" == "success" ] ; then
              RESULT="fixed-skipped"
              RESULT_ICON="‚úÖ"
              RESULT_TEXT="Patch fixed failing tests (before tests skipped)"
            elif [ "$AFTER_STATUS" == "skipped" ] ; then
              RESULT="no-change-both-skipped"
              RESULT_ICON="‚ÑπÔ∏è"
              RESULT_TEXT="Tests skipped before and after patch"
            fi
          fi

          echo "$RESULT_ICON $RESULT_TEXT"

          echo "result=$RESULT" >> $GITHUB_OUTPUT
          echo "result_icon=$RESULT_ICON" >> $GITHUB_OUTPUT
          echo "result_text=$RESULT_TEXT" >> $GITHUB_OUTPUT
          echo "before_status=$BEFORE_STATUS" >> $GITHUB_OUTPUT
          echo "after_status=$AFTER_STATUS" >> $GITHUB_OUTPUT

      - name: Create result summary
        id: summary
        continue-on-error: true
        run: |
          BEFORE_STATUS=$(cat test-output-before-status.txt || echo "skipped")
          AFTER_STATUS=$(cat test-output-after-status.txt || echo "skipped")

          if [ -z "${{ steps.check-patch.outputs.applies }}" ] ; then
            APPLIES="false"
          else
            APPLIES="${{ steps.check-patch.outputs.applies }}"
          fi

          cat > result-summary.json << EOF
          {
            "package": "${{ matrix.package }}",
            "has_patch": ${{ steps.load-patches.outputs.has_patch }},
            "patch_applies": $APPLIES,
            "before_status": "$BEFORE_STATUS",
            "after_status": "$AFTER_STATUS",
            "result": "${{ steps.compare.outputs.result }}",
            "result_icon": "${{ steps.compare.outputs.result_icon }}",
            "result_text": "${{ steps.compare.outputs.result_text }}",
            "patched_packages": "${{ steps.check-patch.outputs.patched_packages }}"
          }
          EOF

          cat result-summary.json

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.package }}
          path: |
            test-output-before.txt
            test-output-after.txt
            test-output-before-status.txt
            test-output-after-status.txt
            test-diff.txt
            result-summary.json
          retention-days: 30

      - name: Fail job if run-tests.sh failed
        if: always()
        run: |
          # Only fail if the test execution step itself failed (not test failures, but script execution failures)
          # Since we use continue-on-error on test steps, we check if run-tests.sh could not be executed
          if [ ! -f test-output-before-status.txt ]; then
            echo "Error: Tests could not be executed"
            exit 1
          fi

          # Fail if tests actually failed (as opposed to passing or being skipped)
          BEFORE_STATUS=$(cat test-output-before-status.txt 2>/dev/null || echo "missing")
          if [ "$BEFORE_STATUS" = "failed" ]; then
            echo "Error: Tests failed before applying patches"
            exit 1
          fi

          # If patches were applied, also check after status
          if [ -f test-output-after-status.txt ]; then
            AFTER_STATUS=$(cat test-output-after-status.txt)
            if [ "$AFTER_STATUS" = "failed" ]; then
              echo "Error: Tests failed after applying patches"
              exit 1
            fi
          fi

  generate-report:
    name: Generate Summary Report
    needs: test-packages
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Generate summary report
        run: |
          mkdir -p report

          # Generate README.md with summary
          echo "# Invenio Bugfix Verification Results" > report/README.md
          echo "" >> report/README.md
          echo "_Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")_" >> report/README.md
          echo "" >> report/README.md

          # Calculate overall statistics
          TOTAL=0
          PATCHED=0
          UNPATCHED=0
          FIXED=0
          REGRESSION=0
          NO_CHANGE=0
          STILL_FAILING=0
          SUCCESS_BEFORE=0
          FAILED_BEFORE=0
          SUCCESS_AFTER=0
          FAILED_AFTER=0

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              TOTAL=$((TOTAL + 1))
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")
              
              if [ "$APPLIES" = "true" ]; then
                PATCHED=$((PATCHED + 1))
                RESULT=$(jq -r '.result' "$dir/result-summary.json")
                case $RESULT in
                  fixed) FIXED=$((FIXED + 1)) ;;
                  regression) REGRESSION=$((REGRESSION + 1)) ;;
                  still-failing) STILL_FAILING=$((STILL_FAILING + 1)) ;;
                  *) NO_CHANGE=$((NO_CHANGE + 1)) ;;
                esac
                
                BEFORE=$(jq -r '.before_status' "$dir/result-summary.json")
                AFTER=$(jq -r '.after_status' "$dir/result-summary.json")
                [ "$BEFORE" = "success" ] && SUCCESS_BEFORE=$((SUCCESS_BEFORE + 1))
                [ "$BEFORE" = "failed" ] && FAILED_BEFORE=$((FAILED_BEFORE + 1))
                [ "$AFTER" = "success" ] && SUCCESS_AFTER=$((SUCCESS_AFTER + 1))
                [ "$AFTER" = "failed" ] && FAILED_AFTER=$((FAILED_AFTER + 1))
              else
                UNPATCHED=$((UNPATCHED + 1))
                BEFORE=$(jq -r '.before_status' "$dir/result-summary.json")
                [ "$BEFORE" = "success" ] && SUCCESS_BEFORE=$((SUCCESS_BEFORE + 1))
                [ "$BEFORE" = "failed" ] && FAILED_BEFORE=$((FAILED_BEFORE + 1))
              fi
            fi
          done

          # Overall Status
          echo "## üìä Overall Status" >> report/README.md
          echo "" >> report/README.md
          echo "| Metric | Count |" >> report/README.md
          echo "|--------|-------|" >> report/README.md
          echo "| **Total Packages** | $TOTAL |" >> report/README.md
          echo "| **Patched Packages** | $PATCHED |" >> report/README.md
          echo "| **Unpatched Packages** | $UNPATCHED |" >> report/README.md
          echo "" >> report/README.md
          echo "### Patch Results" >> report/README.md
          echo "| Result | Count |" >> report/README.md
          echo "|--------|-------|" >> report/README.md
          echo "| ‚úÖ Fixed | $FIXED |" >> report/README.md
          echo "| ‚ùå Regressions | $REGRESSION |" >> report/README.md
          echo "| ‚ö†Ô∏è  Still Failing | $STILL_FAILING |" >> report/README.md
          echo "| ‚ÑπÔ∏è  No Change | $NO_CHANGE |" >> report/README.md
          echo "" >> report/README.md

          # List of patches
          echo "## üîß Configured Patches" >> report/README.md
          echo "" >> report/README.md

          # Extract unique patches from all result files
          PATCHES_FOUND=false
          declare -A PATCH_LIST
          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")
              if [ "$APPLIES" = "true" ]; then
                PATCHED_PKGS=$(jq -r '.patched_packages' "$dir/result-summary.json")
                if [ -n "$PATCHED_PKGS" ] && [ "$PATCHED_PKGS" != "null" ]; then
                  PATCHES_FOUND=true
                  for pkg in $PATCHED_PKGS; do
                    PATCH_LIST[$pkg]=1
                  done
                fi
              fi
            fi
          done

          # Patches from patches.json
          echo "## üîÑ Patched Packages" >> report/README.md
          echo "" >> report/README.md
          echo "| Package | Patches Applied | Before | After | Result |" >> report/README.md
          echo "|---------|----------------|--------|-------|--------|" >> report/README.md

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              HAS_PATCH=$(jq -r '.has_patch' "$dir/result-summary.json")
              if [ "$HAS_PATCH" = "true" ]; then
                PACKAGE=$(jq -r '.package' "$dir/result-summary.json")
                PATCHED_PKGS=$(jq -r '.patched_packages' "$dir/result-summary.json" | tr '\n' ' ')
                BEFORE=$(jq -r '.before_status' "$dir/result-summary.json")
                AFTER=$(jq -r '.after_status' "$dir/result-summary.json")
                RESULT_ICON=$(jq -r '.result_icon' "$dir/result-summary.json")
                RESULT_TEXT=$(jq -r '.result_text' "$dir/result-summary.json")
                
                # Create package directory and copy test outputs
                mkdir -p "report/$PACKAGE"
                if [ -f "$dir/test-output-before.txt" ]; then
                  cp "$dir/test-output-before.txt" "report/$PACKAGE/"
                fi
                if [ -f "$dir/test-output-after.txt" ]; then
                  cp "$dir/test-output-after.txt" "report/$PACKAGE/"
                fi
                if [ -f "$dir/test-diff.txt" ]; then
                  cp "$dir/test-diff.txt" "report/$PACKAGE/"
                fi
                
                # Format status
                case $BEFORE in
                  success) BEFORE_STATUS="‚úÖ Pass" ;;
                  failed) BEFORE_STATUS="‚ùå Fail" ;;
                  skipped) BEFORE_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) BEFORE_STATUS="‚ùì Unknown" ;;
                esac
                
                case $AFTER in
                  success) AFTER_STATUS="‚úÖ Pass" ;;
                  failed) AFTER_STATUS="‚ùå Fail" ;;
                  skipped) AFTER_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) AFTER_STATUS="‚ùì Unknown" ;;
                esac
                
                # Use result_icon and result_text from artifacts
                if [ -n "$RESULT_ICON" ] && [ "$RESULT_ICON" != "null" ]; then
                  RESULT_STATUS="$RESULT_ICON $RESULT_TEXT"
                else
                  RESULT_STATUS="‚ùì Unknown"
                fi
                
                # Create links for test outputs
                LINKS=""
                if [ -f "report/$PACKAGE/test-output-before.txt" ]; then
                  LINKS="$LINKS [before]($PACKAGE/test-output-before.txt)"
                fi
                if [ -f "report/$PACKAGE/test-output-after.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [after]($PACKAGE/test-output-after.txt)"
                fi
                if [ -f "report/$PACKAGE/test-diff.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [diff]($PACKAGE/test-diff.txt)"
                fi
                
                if [ -n "$LINKS" ]; then
                  PACKAGE_DISPLAY="\`$PACKAGE\` <br/> $LINKS"
                else
                  PACKAGE_DISPLAY="\`$PACKAGE\`"
                fi
                
                echo "| $PACKAGE_DISPLAY | $PATCHED_PKGS | $BEFORE_STATUS | $AFTER_STATUS | $RESULT_STATUS |" >> report/README.md
              fi
            fi
          done
          echo "" >> report/README.md

          # Unpatched packages
          echo "## üì¶ Unpatched Packages" >> report/README.md
          echo "" >> report/README.md
          echo "| Package | Build Status |" >> report/README.md
          echo "|---------|--------------|" >> report/README.md

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")
              HAS_PATCH=$(jq -r '.has_patch' "$dir/result-summary.json")
              if [ "$APPLIES" != "true" ] && [ "$HAS_PATCH" != "true" ]; then
                PACKAGE=$(jq -r '.package' "$dir/result-summary.json")
                BEFORE=$(jq -r '.before_status' "$dir/result-summary.json")
                
                # Create package directory and copy test output
                mkdir -p "report/$PACKAGE"
                if [ -f "$dir/test-output-before.txt" ]; then
                  cp "$dir/test-output-before.txt" "report/$PACKAGE/"
                fi
                
                case $BEFORE in
                  success) STATUS="‚úÖ Success" ;;
                  failed) STATUS="‚ùå Failed" ;;
                  skipped) STATUS="‚è≠Ô∏è  Skipped" ;;
                  *) STATUS="‚ùì Unknown" ;;
                esac
                
                # Create link for test output if it exists
                if [ -f "report/$PACKAGE/test-output-before.txt" ]; then
                  PACKAGE_DISPLAY="\`$PACKAGE\` <br/> [output]($PACKAGE/test-output-before.txt)"
                else
                  PACKAGE_DISPLAY="\`$PACKAGE\`"
                fi
                
                echo "| $PACKAGE_DISPLAY | $STATUS |" >> report/README.md
              fi
            fi
          done
          echo "" >> report/README.md

          # Patched packages
          echo "## üîÑ Patched Packages" >> report/README.md
          echo "" >> report/README.md
          echo "| Package | Patches Applied | Before | After | Result |" >> report/README.md
          echo "|---------|----------------|--------|-------|--------|" >> report/README.md

          for dir in artifacts/test-results-*/; do
            if [ -f "$dir/result-summary.json" ]; then
              APPLIES=$(jq -r '.patch_applies' "$dir/result-summary.json")
              if [ "$APPLIES" = "true" ]; then
                PACKAGE=$(jq -r '.package' "$dir/result-summary.json")
                PATCHED_PKGS=$(jq -r '.patched_packages' "$dir/result-summary.json" | tr '\n' ' ')
                BEFORE=$(jq -r '.before_status' "$dir/result-summary.json")
                AFTER=$(jq -r '.after_status' "$dir/result-summary.json")
                RESULT_ICON=$(jq -r '.result_icon' "$dir/result-summary.json")
                RESULT_TEXT=$(jq -r '.result_text' "$dir/result-summary.json")
                
                # Create package directory and copy test outputs
                mkdir -p "report/$PACKAGE"
                if [ -f "$dir/test-output-before.txt" ]; then
                  cp "$dir/test-output-before.txt" "report/$PACKAGE/"
                fi
                if [ -f "$dir/test-output-after.txt" ]; then
                  cp "$dir/test-output-after.txt" "report/$PACKAGE/"
                fi
                if [ -f "$dir/test-diff.txt" ]; then
                  cp "$dir/test-diff.txt" "report/$PACKAGE/"
                fi
                
                # Format status
                case $BEFORE in
                  success) BEFORE_STATUS="‚úÖ Pass" ;;
                  failed) BEFORE_STATUS="‚ùå Fail" ;;
                  skipped) BEFORE_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) BEFORE_STATUS="‚ùì Unknown" ;;
                esac
                
                case $AFTER in
                  success) AFTER_STATUS="‚úÖ Pass" ;;
                  failed) AFTER_STATUS="‚ùå Fail" ;;
                  skipped) AFTER_STATUS="‚è≠Ô∏è  Skip" ;;
                  *) AFTER_STATUS="‚ùì Unknown" ;;
                esac
                
                # Use result_icon and result_text from artifacts
                if [ -n "$RESULT_ICON" ] && [ "$RESULT_ICON" != "null" ]; then
                  RESULT_STATUS="$RESULT_ICON $RESULT_TEXT"
                else
                  RESULT_STATUS="‚ùì Unknown"
                fi
                
                # Create links for test outputs
                LINKS=""
                if [ -f "report/$PACKAGE/test-output-before.txt" ]; then
                  LINKS="$LINKS [before]($PACKAGE/test-output-before.txt)"
                fi
                if [ -f "report/$PACKAGE/test-output-after.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [after]($PACKAGE/test-output-after.txt)"
                fi
                if [ -f "report/$PACKAGE/test-diff.txt" ]; then
                  [ -n "$LINKS" ] && LINKS="$LINKS "
                  LINKS="$LINKS [diff]($PACKAGE/test-diff.txt)"
                fi
                
                if [ -n "$LINKS" ]; then
                  PACKAGE_DISPLAY="\`$PACKAGE\` <br/> $LINKS"
                else
                  PACKAGE_DISPLAY="\`$PACKAGE\`"
                fi
                
                echo "| $PACKAGE_DISPLAY | $PATCHED_PKGS | $BEFORE_STATUS | $AFTER_STATUS | $RESULT_STATUS |" >> report/README.md
              fi
            fi
          done
          echo "" >> report/README.md

          echo "---" >> report/README.md
          echo "" >> report/README.md
          echo "_For detailed test outputs and diffs, see the [full report](https://mesemus.github.io/invenio-bug-verification/)._" >> report/README.md

          cat report/README.md

      - name: Upload README as artifact
        uses: actions/upload-artifact@v4
        with:
          name: verification-readme
          path: report/
          retention-days: 90

      - name: Add README to job summary
        run: |
          cat report/README.md >> $GITHUB_STEP_SUMMARY

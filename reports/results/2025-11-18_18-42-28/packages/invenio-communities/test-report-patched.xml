<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="2" failures="28" skipped="1" tests="715" time="322.354" timestamp="2025-11-18T18:48:00.594706+00:00" hostname="runnervmg1sw1"><testcase classname="invenio_communities.__init__" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.__init__" name="ISORT" time="0.012" /><testcase classname="invenio_communities.__init__" name="black" time="0.293" /><testcase classname="invenio_communities.administration.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.administration.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.administration.__init__" name="black" time="0.163" /><testcase classname="invenio_communities.administration.communities" name="PYDOCSTYLE" time="0.011" /><testcase classname="invenio_communities.administration.communities" name="ISORT" time="0.130" /><testcase classname="invenio_communities.administration.communities" name="black" time="0.189" /><testcase classname="invenio_communities.alembic.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.alembic.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.alembic.__init__" name="black" time="0.168" /><testcase classname="invenio_communities.alembic.02cd82910727_update_role_id_type_upgrade" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.alembic.02cd82910727_update_role_id_type_upgrade" name="ISORT" time="0.015" /><testcase classname="invenio_communities.alembic.02cd82910727_update_role_id_type_upgrade" name="black" time="0.173" /><testcase classname="invenio_communities.alembic.37b21951084c_update_role_id_type_downgrade" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.alembic.37b21951084c_update_role_id_type_downgrade" name="ISORT" time="0.014" /><testcase classname="invenio_communities.alembic.37b21951084c_update_role_id_type_downgrade" name="black" time="0.175" /><testcase classname="invenio_communities.alembic.5b478fe7ef7f_create_featured_communities_table" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.alembic.5b478fe7ef7f_create_featured_communities_table" name="ISORT" time="0.015" /><testcase classname="invenio_communities.alembic.5b478fe7ef7f_create_featured_communities_table" name="black" time="0.182" /><testcase classname="invenio_communities.alembic.5c68d45c80f0_add_deletion_status_to_communities" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.alembic.5c68d45c80f0_add_deletion_status_to_communities" name="ISORT" time="0.020" /><testcase classname="invenio_communities.alembic.5c68d45c80f0_add_deletion_status_to_communities" name="black" time="0.176" /><testcase classname="invenio_communities.alembic.72b37bb4119c_create_indeces_for_bucket_id" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.alembic.72b37bb4119c_create_indeces_for_bucket_id" name="ISORT" time="0.011" /><testcase classname="invenio_communities.alembic.72b37bb4119c_create_indeces_for_bucket_id" name="black" time="0.168" /><testcase classname="invenio_communities.alembic.90642d415317_create_communities_branch" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.alembic.90642d415317_create_communities_branch" name="ISORT" time="0.006" /><testcase classname="invenio_communities.alembic.90642d415317_create_communities_branch" name="black" time="0.166" /><testcase classname="invenio_communities.alembic.a3f5a8635cbb_remove_version_table" name="PYDOCSTYLE" time="0.009" /><testcase classname="invenio_communities.alembic.a3f5a8635cbb_remove_version_table" name="ISORT" time="0.025" /><testcase classname="invenio_communities.alembic.a3f5a8635cbb_remove_version_table" name="black" time="0.188" /><testcase classname="invenio_communities.alembic.de9c14cbb0b2_create_communities_tables" name="PYDOCSTYLE" time="0.016" /><testcase classname="invenio_communities.alembic.de9c14cbb0b2_create_communities_tables" name="ISORT" time="0.037" /><testcase classname="invenio_communities.alembic.de9c14cbb0b2_create_communities_tables" name="black" time="0.208" /><testcase classname="invenio_communities.alembic.f701a32e6fbe_create_communities_members_table" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_communities.alembic.f701a32e6fbe_create_communities_members_table" name="ISORT" time="0.019" /><testcase classname="invenio_communities.alembic.f701a32e6fbe_create_communities_members_table" name="black" time="0.180" /><testcase classname="invenio_communities.alembic.fbe746957cfc_create_member_tables" name="PYDOCSTYLE" time="0.014" /><testcase classname="invenio_communities.alembic.fbe746957cfc_create_member_tables" name="ISORT" time="0.038" /><testcase classname="invenio_communities.alembic.fbe746957cfc_create_member_tables" name="black" time="0.203" /><testcase classname="invenio_communities.cache.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.cache.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.cache.__init__" name="black" time="0.163" /><testcase classname="invenio_communities.cache.cache" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_communities.cache.cache" name="ISORT" time="0.013" /><testcase classname="invenio_communities.cache.cache" name="black" time="0.171" /><testcase classname="invenio_communities.cache.redis" name="PYDOCSTYLE" time="0.009" /><testcase classname="invenio_communities.cache.redis" name="ISORT" time="0.017" /><testcase classname="invenio_communities.cache.redis" name="black" time="0.175" /><testcase classname="invenio_communities.cli" name="PYDOCSTYLE" time="0.014" /><testcase classname="invenio_communities.cli" name="ISORT" time="0.035" /><testcase classname="invenio_communities.cli" name="black" time="0.192" /><testcase classname="invenio_communities.communities.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.__init__" name="ISORT" time="0.008" /><testcase classname="invenio_communities.communities.__init__" name="black" time="0.167" /><testcase classname="invenio_communities.communities.dumpers.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.dumpers.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.communities.dumpers.__init__" name="black" time="0.166" /><testcase classname="invenio_communities.communities.dumpers.featured" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_communities.communities.dumpers.featured" name="ISORT" time="0.014" /><testcase classname="invenio_communities.communities.dumpers.featured" name="black" time="0.173" /><testcase classname="invenio_communities.communities.entity_resolvers" name="PYDOCSTYLE" time="0.011" /><testcase classname="invenio_communities.communities.entity_resolvers" name="ISORT" time="0.021" /><testcase classname="invenio_communities.communities.entity_resolvers" name="black" time="0.179" /><testcase classname="invenio_communities.communities.records.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.records.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.communities.records.__init__" name="black" time="0.159" /><testcase classname="invenio_communities.communities.records.api" name="PYDOCSTYLE" time="0.010" /><testcase classname="invenio_communities.communities.records.api" name="ISORT" time="0.038" /><testcase classname="invenio_communities.communities.records.api" name="black" time="0.183" /><testcase classname="invenio_communities.communities.records.jsonschemas.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.records.jsonschemas.__init__" name="ISORT" time="0.005" /><testcase classname="invenio_communities.communities.records.jsonschemas.__init__" name="black" time="0.163" /><testcase classname="invenio_communities.communities.records.mappings.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.records.mappings.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.communities.records.mappings.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.communities.records.mappings.os-v1.__init__" name="PYDOCSTYLE" time="0.002" /><testcase classname="invenio_communities.communities.records.mappings.os-v1.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.communities.records.mappings.os-v1.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.communities.records.mappings.os-v2.__init__" name="PYDOCSTYLE" time="0.002" /><testcase classname="invenio_communities.communities.records.mappings.os-v2.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.communities.records.mappings.os-v2.__init__" name="black" time="0.167" /><testcase classname="invenio_communities.communities.records.mappings.v7.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.records.mappings.v7.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.communities.records.mappings.v7.__init__" name="black" time="0.159" /><testcase classname="invenio_communities.communities.records.models" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.communities.records.models" name="ISORT" time="0.018" /><testcase classname="invenio_communities.communities.records.models" name="black" time="0.173" /><testcase classname="invenio_communities.communities.records.systemfields.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.records.systemfields.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.communities.records.systemfields.__init__" name="black" time="0.164" /><testcase classname="invenio_communities.communities.records.systemfields.access" name="PYDOCSTYLE" time="0.031" /><testcase classname="invenio_communities.communities.records.systemfields.access" name="ISORT" time="0.049" /><testcase classname="invenio_communities.communities.records.systemfields.access" name="black" time="0.222" /><testcase classname="invenio_communities.communities.records.systemfields.children" name="PYDOCSTYLE" time="0.011" /><testcase classname="invenio_communities.communities.records.systemfields.children" name="ISORT" time="0.019" /><testcase classname="invenio_communities.communities.records.systemfields.children" name="black" time="0.185" /><testcase classname="invenio_communities.communities.records.systemfields.deletion_status" name="PYDOCSTYLE" time="0.014" /><testcase classname="invenio_communities.communities.records.systemfields.deletion_status" name="ISORT" time="0.022" /><testcase classname="invenio_communities.communities.records.systemfields.deletion_status" name="black" time="0.190" /><testcase classname="invenio_communities.communities.records.systemfields.is_verified" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.communities.records.systemfields.is_verified" name="ISORT" time="0.012" /><testcase classname="invenio_communities.communities.records.systemfields.is_verified" name="black" time="0.174" /><testcase classname="invenio_communities.communities.records.systemfields.parent_community" name="PYDOCSTYLE" time="0.011" /><testcase classname="invenio_communities.communities.records.systemfields.parent_community" name="ISORT" time="0.025" /><testcase classname="invenio_communities.communities.records.systemfields.parent_community" name="black" time="0.188" /><testcase classname="invenio_communities.communities.records.systemfields.pidslug" name="PYDOCSTYLE" time="0.010" /><testcase classname="invenio_communities.communities.records.systemfields.pidslug" name="ISORT" time="0.020" /><testcase classname="invenio_communities.communities.records.systemfields.pidslug" name="black" time="0.184" /><testcase classname="invenio_communities.communities.records.systemfields.tombstone" name="PYDOCSTYLE" time="0.019" /><testcase classname="invenio_communities.communities.records.systemfields.tombstone" name="ISORT" time="0.032" /><testcase classname="invenio_communities.communities.records.systemfields.tombstone" name="black" time="0.197" /><testcase classname="invenio_communities.communities.resources.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.resources.__init__" name="ISORT" time="0.006" /><testcase classname="invenio_communities.communities.resources.__init__" name="black" time="0.165" /><testcase classname="invenio_communities.communities.resources.args" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.resources.args" name="ISORT" time="0.008" /><testcase classname="invenio_communities.communities.resources.args" name="black" time="0.160" /><testcase classname="invenio_communities.communities.resources.config" name="PYDOCSTYLE" time="0.008" /><testcase classname="invenio_communities.communities.resources.config" name="ISORT" time="0.029" /><testcase classname="invenio_communities.communities.resources.config" name="black" time="0.184" /><testcase classname="invenio_communities.communities.resources.resource" name="PYDOCSTYLE" time="0.023" /><testcase classname="invenio_communities.communities.resources.resource" name="ISORT" time="0.044" /><testcase classname="invenio_communities.communities.resources.resource" name="black" time="0.207" /><testcase classname="invenio_communities.communities.resources.serializer" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.communities.resources.serializer" name="ISORT" time="0.010" /><testcase classname="invenio_communities.communities.resources.serializer" name="black" time="0.165" /><testcase classname="invenio_communities.communities.resources.ui_schema" name="PYDOCSTYLE" time="0.015" /><testcase classname="invenio_communities.communities.resources.ui_schema" name="ISORT" time="0.037" /><testcase classname="invenio_communities.communities.resources.ui_schema" name="black" time="0.198" /><testcase classname="invenio_communities.communities.schema" name="PYDOCSTYLE" time="0.026" /><testcase classname="invenio_communities.communities.schema" name="ISORT" time="0.060" /><testcase classname="invenio_communities.communities.schema" name="black" time="0.220" /><testcase classname="invenio_communities.communities.services.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.communities.services.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_communities.communities.services.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.communities.services.components" name="PYDOCSTYLE" time="0.038" /><testcase classname="invenio_communities.communities.services.components" name="ISORT" time="0.067" /><testcase classname="invenio_communities.communities.services.components" name="black" time="0.240" /><testcase classname="invenio_communities.communities.services.config" name="PYDOCSTYLE" time="0.012" /><testcase classname="invenio_communities.communities.services.config" name="ISORT" time="0.041" /><testcase classname="invenio_communities.communities.services.config" name="black" time="0.191" /><testcase classname="invenio_communities.communities.services.facets" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.communities.services.facets" name="ISORT" time="0.014" /><testcase classname="invenio_communities.communities.services.facets" name="black" time="0.173" /><testcase classname="invenio_communities.communities.services.links" name="PYDOCSTYLE" time="0.009" /><testcase classname="invenio_communities.communities.services.links" name="ISORT" time="0.016" /><testcase classname="invenio_communities.communities.services.links" name="black" time="0.173" /><testcase classname="invenio_communities.communities.services.results" name="PYDOCSTYLE" time="0.011" /><testcase classname="invenio_communities.communities.services.results" name="ISORT" time="0.022" /><testcase classname="invenio_communities.communities.services.results" name="black" time="0.184" /><testcase classname="invenio_communities.communities.services.search_params" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.communities.services.search_params" name="ISORT" time="0.012" /><testcase classname="invenio_communities.communities.services.search_params" name="black" time="0.169" /><testcase classname="invenio_communities.communities.services.service" name="PYDOCSTYLE" time="0.057" /><testcase classname="invenio_communities.communities.services.service" name="ISORT" time="0.126" /><testcase classname="invenio_communities.communities.services.service" name="black" time="0.309" /><testcase classname="invenio_communities.communities.services.sort" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.communities.services.sort" name="ISORT" time="0.010" /><testcase classname="invenio_communities.communities.services.sort" name="black" time="0.167" /><testcase classname="invenio_communities.communities.services.uow" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.communities.services.uow" name="ISORT" time="0.011" /><testcase classname="invenio_communities.communities.services.uow" name="black" time="0.165" /><testcase classname="invenio_communities.config" name="PYDOCSTYLE" time="0.014" /><testcase classname="invenio_communities.config" name="ISORT" time="0.053" /><testcase classname="invenio_communities.config" name="black" time="0.212" /><testcase classname="invenio_communities.errors" name="PYDOCSTYLE" time="0.010" /><testcase classname="invenio_communities.errors" name="ISORT" time="0.020" /><testcase classname="invenio_communities.errors" name="black" time="0.180" /><testcase classname="invenio_communities.ext" name="PYDOCSTYLE" time="0.020" /><testcase classname="invenio_communities.ext" name="ISORT" time="0.042" /><testcase classname="invenio_communities.ext" name="black" time="0.200" /><testcase classname="invenio_communities.fixtures.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.fixtures.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.fixtures.__init__" name="black" time="0.165" /><testcase classname="invenio_communities.fixtures.demo" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.fixtures.demo" name="ISORT" time="0.010" /><testcase classname="invenio_communities.fixtures.demo" name="black" time="0.174" /><testcase classname="invenio_communities.fixtures.tasks" name="PYDOCSTYLE" time="0.008" /><testcase classname="invenio_communities.fixtures.tasks" name="ISORT" time="0.021" /><testcase classname="invenio_communities.fixtures.tasks" name="black" time="0.177" /><testcase classname="invenio_communities.generators" name="PYDOCSTYLE" time="0.042" /><testcase classname="invenio_communities.generators" name="ISORT" time="0.067" /><testcase classname="invenio_communities.generators" name="black" time="0.248" /><testcase classname="invenio_communities.members.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.members.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_communities.members.__init__" name="black" time="0.163" /><testcase classname="invenio_communities.members.errors" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.members.errors" name="ISORT" time="0.006" /><testcase classname="invenio_communities.members.errors" name="black" time="0.163" /><testcase classname="invenio_communities.members.records.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.members.records.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_communities.members.records.__init__" name="black" time="0.163" /><testcase classname="invenio_communities.members.records.api" name="PYDOCSTYLE" time="0.017" /><testcase classname="invenio_communities.members.records.api" name="ISORT" time="0.043" /><testcase classname="invenio_communities.members.records.api" name="black" time="0.199" /><testcase classname="invenio_communities.members.records.mappings.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.members.records.mappings.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.members.records.mappings.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.members.records.mappings.os-v1.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.members.records.mappings.os-v1.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.members.records.mappings.os-v1.__init__" name="black" time="0.160" /><testcase classname="invenio_communities.members.records.mappings.os-v2.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.members.records.mappings.os-v2.__init__" name="ISORT" time="0.005" /><testcase classname="invenio_communities.members.records.mappings.os-v2.__init__" name="black" time="0.159" /><testcase classname="invenio_communities.members.records.mappings.v7.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.members.records.mappings.v7.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.members.records.mappings.v7.__init__" name="black" time="0.160" /><testcase classname="invenio_communities.members.records.models" name="PYDOCSTYLE" time="0.015" /><testcase classname="invenio_communities.members.records.models" name="ISORT" time="0.032" /><testcase classname="invenio_communities.members.records.models" name="black" time="0.191" /><testcase classname="invenio_communities.members.resources.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.members.resources.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_communities.members.resources.__init__" name="black" time="0.166" /><testcase classname="invenio_communities.members.resources.config" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.members.resources.config" name="ISORT" time="0.017" /><testcase classname="invenio_communities.members.resources.config" name="black" time="0.174" /><testcase classname="invenio_communities.members.resources.resource" name="PYDOCSTYLE" time="0.014" /><testcase classname="invenio_communities.members.resources.resource" name="ISORT" time="0.028" /><testcase classname="invenio_communities.members.resources.resource" name="black" time="0.191" /><testcase classname="invenio_communities.members.services.__init__" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.members.services.__init__" name="ISORT" time="0.009" /><testcase classname="invenio_communities.members.services.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.members.services.components" name="PYDOCSTYLE" time="0.010" /><testcase classname="invenio_communities.members.services.components" name="ISORT" time="0.021" /><testcase classname="invenio_communities.members.services.components" name="black" time="0.181" /><testcase classname="invenio_communities.members.services.config" name="PYDOCSTYLE" time="0.012" /><testcase classname="invenio_communities.members.services.config" name="ISORT" time="0.039" /><testcase classname="invenio_communities.members.services.config" name="black" time="0.200" /><testcase classname="invenio_communities.members.services.facets" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.members.services.facets" name="ISORT" time="0.013" /><testcase classname="invenio_communities.members.services.facets" name="black" time="0.176" /><testcase classname="invenio_communities.members.services.fields" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.members.services.fields" name="ISORT" time="0.012" /><testcase classname="invenio_communities.members.services.fields" name="black" time="0.172" /><testcase classname="invenio_communities.members.services.request" name="PYDOCSTYLE" time="0.013" /><testcase classname="invenio_communities.members.services.request" name="ISORT" time="0.030" /><testcase classname="invenio_communities.members.services.request" name="black" time="0.186" /><testcase classname="invenio_communities.members.services.schemas" name="PYDOCSTYLE" time="0.019" /><testcase classname="invenio_communities.members.services.schemas" name="ISORT" time="0.038" /><testcase classname="invenio_communities.members.services.schemas" name="black" time="0.205" /><testcase classname="invenio_communities.members.services.service" name="PYDOCSTYLE" time="0.057" /><testcase classname="invenio_communities.members.services.service" name="ISORT" time="0.130" /><testcase classname="invenio_communities.members.services.service" name="black" time="0.303" /><testcase classname="invenio_communities.notifications.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.notifications.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.notifications.__init__" name="black" time="0.167" /><testcase classname="invenio_communities.notifications.builders" name="PYDOCSTYLE" time="0.022" /><testcase classname="invenio_communities.notifications.builders" name="ISORT" time="0.057" /><testcase classname="invenio_communities.notifications.builders" name="black" time="0.212" /><testcase classname="invenio_communities.notifications.generators" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_communities.notifications.generators" name="ISORT" time="0.018" /><testcase classname="invenio_communities.notifications.generators" name="black" time="0.173" /><testcase classname="invenio_communities.permissions" name="PYDOCSTYLE" time="0.013" /><testcase classname="invenio_communities.permissions" name="ISORT" time="0.035" /><testcase classname="invenio_communities.permissions" name="black" time="0.196" /><testcase classname="invenio_communities.proxies" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.proxies" name="ISORT" time="0.010" /><testcase classname="invenio_communities.proxies" name="black" time="0.166" /><testcase classname="invenio_communities.records.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.records.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.records.__init__" name="black" time="0.161" /><testcase classname="invenio_communities.records.records.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.records.records.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.records.records.__init__" name="black" time="0.164" /><testcase classname="invenio_communities.records.records.models" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_communities.records.records.models" name="ISORT" time="0.015" /><testcase classname="invenio_communities.records.records.models" name="black" time="0.173" /><testcase classname="invenio_communities.records.records.systemfields.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.records.records.systemfields.__init__" name="ISORT" time="0.006" /><testcase classname="invenio_communities.records.records.systemfields.__init__" name="black" time="0.161" /><testcase classname="invenio_communities.records.records.systemfields.communities.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.records.records.systemfields.communities.__init__" name="ISORT" time="0.004" /><testcase classname="invenio_communities.records.records.systemfields.communities.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.records.records.systemfields.communities.context" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.records.records.systemfields.communities.context" name="ISORT" time="0.008" /><testcase classname="invenio_communities.records.records.systemfields.communities.context" name="black" time="0.169" /><testcase classname="invenio_communities.records.records.systemfields.communities.field" name="PYDOCSTYLE" time="0.011" /><testcase classname="invenio_communities.records.records.systemfields.communities.field" name="ISORT" time="0.023" /><testcase classname="invenio_communities.records.records.systemfields.communities.field" name="black" time="0.188" /><testcase classname="invenio_communities.records.records.systemfields.communities.manager" name="PYDOCSTYLE" time="0.021" /><testcase classname="invenio_communities.records.records.systemfields.communities.manager" name="ISORT" time="0.036" /><testcase classname="invenio_communities.records.records.systemfields.communities.manager" name="black" time="0.204" /><testcase classname="invenio_communities.requests.user_moderation.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.requests.user_moderation.__init__" name="ISORT" time="0.005" /><testcase classname="invenio_communities.requests.user_moderation.__init__" name="black" time="0.170" /><testcase classname="invenio_communities.requests.user_moderation.actions" name="PYDOCSTYLE" time="0.012" /><testcase classname="invenio_communities.requests.user_moderation.actions" name="ISORT" time="0.027" /><testcase classname="invenio_communities.requests.user_moderation.actions" name="black" time="0.187" /><testcase classname="invenio_communities.requests.user_moderation.tasks" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.requests.user_moderation.tasks" name="ISORT" time="0.012" /><testcase classname="invenio_communities.requests.user_moderation.tasks" name="black" time="0.173" /><testcase classname="invenio_communities.roles" name="PYDOCSTYLE" time="0.012" /><testcase classname="invenio_communities.roles" name="ISORT" time="0.021" /><testcase classname="invenio_communities.roles" name="black" time="0.181" /><testcase classname="invenio_communities.searchapp" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_communities.searchapp" name="ISORT" time="0.016" /><testcase classname="invenio_communities.searchapp" name="black" time="0.178" /><testcase classname="invenio_communities.subcommunities.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.subcommunities.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_communities.subcommunities.__init__" name="black" time="0.163" /><testcase classname="invenio_communities.subcommunities.resources.__init__" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.subcommunities.resources.__init__" name="ISORT" time="0.008" /><testcase classname="invenio_communities.subcommunities.resources.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.subcommunities.resources.config" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.subcommunities.resources.config" name="ISORT" time="0.017" /><testcase classname="invenio_communities.subcommunities.resources.config" name="black" time="0.172" /><testcase classname="invenio_communities.subcommunities.resources.resource" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.subcommunities.resources.resource" name="ISORT" time="0.013" /><testcase classname="invenio_communities.subcommunities.resources.resource" name="black" time="0.169" /><testcase classname="invenio_communities.subcommunities.services.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.subcommunities.services.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_communities.subcommunities.services.__init__" name="black" time="0.162" /><testcase classname="invenio_communities.subcommunities.services.config" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_communities.subcommunities.services.config" name="ISORT" time="0.017" /><testcase classname="invenio_communities.subcommunities.services.config" name="black" time="0.165" /><testcase classname="invenio_communities.subcommunities.services.errors" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_communities.subcommunities.services.errors" name="ISORT" time="0.005" /><testcase classname="invenio_communities.subcommunities.services.errors" name="black" time="0.162" /><testcase classname="invenio_communities.subcommunities.services.request" name="PYDOCSTYLE" time="0.017" /><testcase classname="invenio_communities.subcommunities.services.request" name="ISORT" time="0.038" /><testcase classname="invenio_communities.subcommunities.services.request" name="black" time="0.191" /><testcase classname="invenio_communities.subcommunities.services.schema" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.subcommunities.services.schema" name="ISORT" time="0.013" /><testcase classname="invenio_communities.subcommunities.services.schema" name="black" time="0.170" /><testcase classname="invenio_communities.subcommunities.services.service" name="PYDOCSTYLE" time="0.015" /><testcase classname="invenio_communities.subcommunities.services.service" name="ISORT" time="0.038" /><testcase classname="invenio_communities.subcommunities.services.service" name="black" time="0.197" /><testcase classname="invenio_communities.tasks" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.tasks" name="ISORT" time="0.008" /><testcase classname="invenio_communities.tasks" name="black" time="0.163" /><testcase classname="invenio_communities.utils" name="PYDOCSTYLE" time="0.011" /><testcase classname="invenio_communities.utils" name="ISORT" time="0.024" /><testcase classname="invenio_communities.utils" name="black" time="0.182" /><testcase classname="invenio_communities.views.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="invenio_communities.views.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_communities.views.__init__" name="black" time="0.165" /><testcase classname="invenio_communities.views.api" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_communities.views.api" name="ISORT" time="0.010" /><testcase classname="invenio_communities.views.api" name="black" time="0.173" /><testcase classname="invenio_communities.views.communities" name="PYDOCSTYLE" time="0.039" /><testcase classname="invenio_communities.views.communities" name="ISORT" time="0.092" /><testcase classname="invenio_communities.views.communities" name="black" time="0.262" /><testcase classname="invenio_communities.views.decorators" name="PYDOCSTYLE" time="0.008" /><testcase classname="invenio_communities.views.decorators" name="ISORT" time="0.016" /><testcase classname="invenio_communities.views.decorators" name="black" time="0.171" /><testcase classname="invenio_communities.views.template_loader" name="PYDOCSTYLE" time="0.009" /><testcase classname="invenio_communities.views.template_loader" name="ISORT" time="0.017" /><testcase classname="invenio_communities.views.template_loader" name="black" time="0.171" /><testcase classname="invenio_communities.views.ui" name="PYDOCSTYLE" time="0.018" /><testcase classname="invenio_communities.views.ui" name="ISORT" time="0.046" /><testcase classname="invenio_communities.views.ui" name="black" time="0.200" /><testcase classname="invenio_communities.webpack" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_communities.webpack" name="ISORT" time="0.018" /><testcase classname="invenio_communities.webpack" name="black" time="0.181" /><testcase classname="setup" name="PYDOCSTYLE" time="0.003" /><testcase classname="setup" name="ISORT" time="0.007" /><testcase classname="setup" name="black" time="0.164" /><testcase classname="tests.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="tests.__init__" name="ISORT" time="0.004" /><testcase classname="tests.__init__" name="black" time="0.166" /><testcase classname="tests.cache.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="tests.cache.__init__" name="ISORT" time="0.004" /><testcase classname="tests.cache.__init__" name="black" time="0.161" /><testcase classname="tests.cache.test_identity_redis_cache" name="ISORT" time="0.012" /><testcase classname="tests.cache.test_identity_redis_cache" name="black" time="0.168" /><testcase classname="tests.cache.test_identity_redis_cache" name="test_cache_deletion" time="4.268" /><testcase classname="tests.cache.test_identity_redis_cache" name="test_cache_flush" time="0.004" /><testcase classname="tests.cache.test_identity_redis_cache" name="test_default_prefix_for_redis" time="0.002" /><testcase classname="tests.cache.test_identity_redis_cache" name="test_timeout_config" time="3.515" /><testcase classname="tests.communities.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="tests.communities.__init__" name="ISORT" time="0.004" /><testcase classname="tests.communities.__init__" name="black" time="0.158" /><testcase classname="tests.communities.conftest" name="PYDOCSTYLE" time="0.008" /><testcase classname="tests.communities.conftest" name="ISORT" time="0.021" /><testcase classname="tests.communities.conftest" name="black" time="0.171" /><testcase classname="tests.communities.test_alembic" name="ISORT" time="0.014" /><testcase classname="tests.communities.test_alembic" name="black" time="0.168" /><testcase classname="tests.communities.test_alembic" name="test_alembic" time="0.000"><skipped type="pytest.skip" message="Caused by mergepoint">/home/runner/work/invenio-bug-verification/invenio-bug-verification/package-repo/tests/communities/test_alembic.py:21: Caused by mergepoint</skipped></testcase><testcase classname="tests.communities.test_cli" name="ISORT" time="0.016" /><testcase classname="tests.communities.test_cli" name="black" time="0.171" /><testcase classname="tests.communities.test_cli" name="test_fake_demo_community_creation" time="6.387" /><testcase classname="tests.communities.test_cli" name="test_create_communities_custom_fields" time="2.931" /><testcase classname="tests.communities.test_community_ui_serializer" name="ISORT" time="0.018" /><testcase classname="tests.communities.test_community_ui_serializer" name="black" time="0.177" /><testcase classname="tests.communities.test_community_ui_serializer" name="test_ui_serializer" time="3.633" /><testcase classname="tests.communities.test_components" name="ISORT" time="0.037" /><testcase classname="tests.communities.test_components" name="black" time="0.222" /><testcase classname="tests.communities.test_components" name="test_oai_set_create_community" time="3.002" /><testcase classname="tests.communities.test_components" name="test_oai_set_delete_community" time="0.365" /><testcase classname="tests.communities.test_components" name="test_oai_set_renamed" time="0.377" /><testcase classname="tests.communities.test_components" name="test_oai_set_update" time="0.393" /><testcase classname="tests.communities.test_components" name="test_children_component" time="0.506" /><testcase classname="tests.communities.test_components" name="test_children_component_without_children" time="1.259" /><testcase classname="tests.communities.test_parent_community" name="ISORT" time="0.020" /><testcase classname="tests.communities.test_parent_community" name="black" time="0.182" /><testcase classname="tests.communities.test_parent_community" name="test_set_parent_community_with_comm_obj" time="3.462" /><testcase classname="tests.communities.test_parent_community" name="test_set_parent_community_with_comm_uuid" time="0.313"><failure message="sqlalchemy.orm.exc.StaleDataError: Version id '3' on merged state &lt;CommunityMetadata at 0x7fb0fbe883e0&gt; does not match existing version '5'. Leave the version attribute unset when merging to update the most recent version.">parent_community = {'$schema': 'local://communities/communities-v1.0.0.json', 'files': {'enabled': True}, 'metadata': {'title': 'My Commu...members_visibility': 'public', 'member_policy': 'open', 'record_submission_policy': 'open', 'review_policy': 'closed'}}
child_community = {'$schema': 'local://communities/communities-v1.0.0.json', 'files': {'enabled': True}, 'metadata': {'title': 'My Commu...ecord_submission_policy': 'open', 'review_policy': 'closed'}, 'parent': {'id': '39dbdf4e-e0e3-416a-bf43-6054510afaab'}}
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    def test_set_parent_community_with_comm_uuid(parent_community, child_community, db):
        child_community.parent = parent_community.id
    
        assert child_community.parent == parent_community
    
&gt;       child_community.commit()

tests/communities/test_parent_community.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_records/api.py:461: in commit
    db.session.merge(self.model)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/scoping.py:1553: in merge
    return self._proxied.merge(instance, load=load, options=options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3945: in merge
    return self._merge(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.orm.session.PytestInvenioSession object at 0x7fb0fc101f70&gt;
state = &lt;sqlalchemy.orm.state.InstanceState object at 0x7fb0fc5f4470&gt;
state_dict = {'_sa_instance_state': &lt;sqlalchemy.orm.state.InstanceState object at 0x7fb0fc5f4470&gt;, 'bucket_id': UUID('56d55ee1-c519...tetime.datetime(2025, 11, 18, 18, 49, 2, 376822), 'deletion_status': &lt;CommunityDeletionStatusEnum.PUBLISHED: 'P'&gt;, ...}

    def _merge(
        self,
        state: InstanceState[_O],
        state_dict: _InstanceDict,
        *,
        options: Optional[Sequence[ORMOption]] = None,
        load: bool,
        _recursive: Dict[Any, object],
        _resolve_conflict_map: Dict[_IdentityKeyType[Any], object],
    ) -&gt; _O:
        mapper: Mapper[_O] = _state_mapper(state)
        if state in _recursive:
            return cast(_O, _recursive[state])
    
        new_instance = False
        key = state.key
    
        merged: Optional[_O]
    
        if key is None:
            if state in self._new:
                util.warn(
                    "Instance %s is already pending in this Session yet is "
                    "being merged again; this is probably not what you want "
                    "to do" % state_str(state)
                )
    
            if not load:
                raise sa_exc.InvalidRequestError(
                    "merge() with load=False option does not support "
                    "objects transient (i.e. unpersisted) objects.  flush() "
                    "all changes on mapped instances before merging with "
                    "load=False."
                )
            key = mapper._identity_key_from_state(state)
            key_is_persistent = LoaderCallableStatus.NEVER_SET not in key[
                1
            ] and (
                not _none_set.intersection(key[1])
                or (
                    mapper.allow_partial_pks
                    and not _none_set.issuperset(key[1])
                )
            )
        else:
            key_is_persistent = True
    
        merged = self.identity_map.get(key)
    
        if merged is None:
            if key_is_persistent and key in _resolve_conflict_map:
                merged = cast(_O, _resolve_conflict_map[key])
    
            elif not load:
                if state.modified:
                    raise sa_exc.InvalidRequestError(
                        "merge() with load=False option does not support "
                        "objects marked as 'dirty'.  flush() all changes on "
                        "mapped instances before merging with load=False."
                    )
                merged = mapper.class_manager.new_instance()
                merged_state = attributes.instance_state(merged)
                merged_state.key = key
                self._update_impl(merged_state)
                new_instance = True
    
            elif key_is_persistent:
                merged = self.get(
                    mapper.class_,
                    key[1],
                    identity_token=key[2],
                    options=options,
                )
    
        if merged is None:
            merged = mapper.class_manager.new_instance()
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)
            new_instance = True
            self._save_or_update_state(merged_state)
        else:
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)
    
        _recursive[state] = merged
        _resolve_conflict_map[key] = merged
    
        # check that we didn't just pull the exact same
        # state out.
        if state is not merged_state:
            # version check if applicable
            if mapper.version_id_col is not None:
                existing_version = mapper._get_state_attr_by_column(
                    state,
                    state_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
    
                merged_version = mapper._get_state_attr_by_column(
                    merged_state,
                    merged_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
    
                if (
                    existing_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and merged_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and existing_version != merged_version
                ):
&gt;                   raise exc.StaleDataError(
                        "Version id '%s' on merged state %s "
                        "does not match existing version '%s'. "
                        "Leave the version attribute unset when "
                        "merging to update the most recent version."
                        % (
                            existing_version,
                            state_str(merged_state),
                            merged_version,
                        )
                    )
E                   sqlalchemy.orm.exc.StaleDataError: Version id '3' on merged state &lt;CommunityMetadata at 0x7fb0fbe883e0&gt; does not match existing version '5'. Leave the version attribute unset when merging to update the most recent version.

.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4069: StaleDataError</failure></testcase><testcase classname="tests.communities.test_parent_community" name="test_set_parent_community_with_comm_uuid_string" time="0.303"><failure message="sqlalchemy.orm.exc.StaleDataError: Version id '3' on merged state &lt;CommunityMetadata at 0x7fb0fbab2f60&gt; does not match existing version '5'. Leave the version attribute unset when merging to update the most recent version.">parent_community = {'$schema': 'local://communities/communities-v1.0.0.json', 'files': {'enabled': True}, 'metadata': {'title': 'My Commu...members_visibility': 'public', 'member_policy': 'open', 'record_submission_policy': 'open', 'review_policy': 'closed'}}
child_community = {'$schema': 'local://communities/communities-v1.0.0.json', 'files': {'enabled': True}, 'metadata': {'title': 'My Commu...ecord_submission_policy': 'open', 'review_policy': 'closed'}, 'parent': {'id': '39dbdf4e-e0e3-416a-bf43-6054510afaab'}}
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    def test_set_parent_community_with_comm_uuid_string(
        parent_community, child_community, db
    ):
        child_community.parent = str(parent_community.id)
    
        assert child_community.parent == parent_community
    
&gt;       child_community.commit()

tests/communities/test_parent_community.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_records/api.py:461: in commit
    db.session.merge(self.model)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/scoping.py:1553: in merge
    return self._proxied.merge(instance, load=load, options=options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3945: in merge
    return self._merge(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.orm.session.PytestInvenioSession object at 0x7fb0fbab1d90&gt;
state = &lt;sqlalchemy.orm.state.InstanceState object at 0x7fb0fc5f4470&gt;
state_dict = {'_sa_instance_state': &lt;sqlalchemy.orm.state.InstanceState object at 0x7fb0fc5f4470&gt;, 'bucket_id': UUID('56d55ee1-c519...tetime.datetime(2025, 11, 18, 18, 49, 2, 376822), 'deletion_status': &lt;CommunityDeletionStatusEnum.PUBLISHED: 'P'&gt;, ...}

    def _merge(
        self,
        state: InstanceState[_O],
        state_dict: _InstanceDict,
        *,
        options: Optional[Sequence[ORMOption]] = None,
        load: bool,
        _recursive: Dict[Any, object],
        _resolve_conflict_map: Dict[_IdentityKeyType[Any], object],
    ) -&gt; _O:
        mapper: Mapper[_O] = _state_mapper(state)
        if state in _recursive:
            return cast(_O, _recursive[state])
    
        new_instance = False
        key = state.key
    
        merged: Optional[_O]
    
        if key is None:
            if state in self._new:
                util.warn(
                    "Instance %s is already pending in this Session yet is "
                    "being merged again; this is probably not what you want "
                    "to do" % state_str(state)
                )
    
            if not load:
                raise sa_exc.InvalidRequestError(
                    "merge() with load=False option does not support "
                    "objects transient (i.e. unpersisted) objects.  flush() "
                    "all changes on mapped instances before merging with "
                    "load=False."
                )
            key = mapper._identity_key_from_state(state)
            key_is_persistent = LoaderCallableStatus.NEVER_SET not in key[
                1
            ] and (
                not _none_set.intersection(key[1])
                or (
                    mapper.allow_partial_pks
                    and not _none_set.issuperset(key[1])
                )
            )
        else:
            key_is_persistent = True
    
        merged = self.identity_map.get(key)
    
        if merged is None:
            if key_is_persistent and key in _resolve_conflict_map:
                merged = cast(_O, _resolve_conflict_map[key])
    
            elif not load:
                if state.modified:
                    raise sa_exc.InvalidRequestError(
                        "merge() with load=False option does not support "
                        "objects marked as 'dirty'.  flush() all changes on "
                        "mapped instances before merging with load=False."
                    )
                merged = mapper.class_manager.new_instance()
                merged_state = attributes.instance_state(merged)
                merged_state.key = key
                self._update_impl(merged_state)
                new_instance = True
    
            elif key_is_persistent:
                merged = self.get(
                    mapper.class_,
                    key[1],
                    identity_token=key[2],
                    options=options,
                )
    
        if merged is None:
            merged = mapper.class_manager.new_instance()
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)
            new_instance = True
            self._save_or_update_state(merged_state)
        else:
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)
    
        _recursive[state] = merged
        _resolve_conflict_map[key] = merged
    
        # check that we didn't just pull the exact same
        # state out.
        if state is not merged_state:
            # version check if applicable
            if mapper.version_id_col is not None:
                existing_version = mapper._get_state_attr_by_column(
                    state,
                    state_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
    
                merged_version = mapper._get_state_attr_by_column(
                    merged_state,
                    merged_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
    
                if (
                    existing_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and merged_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and existing_version != merged_version
                ):
&gt;                   raise exc.StaleDataError(
                        "Version id '%s' on merged state %s "
                        "does not match existing version '%s'. "
                        "Leave the version attribute unset when "
                        "merging to update the most recent version."
                        % (
                            existing_version,
                            state_str(merged_state),
                            merged_version,
                        )
                    )
E                   sqlalchemy.orm.exc.StaleDataError: Version id '3' on merged state &lt;CommunityMetadata at 0x7fb0fbab2f60&gt; does not match existing version '5'. Leave the version attribute unset when merging to update the most recent version.

.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4069: StaleDataError</failure></testcase><testcase classname="tests.communities.test_parent_community" name="test_invalid_set_parent_community_with_comm_slug" time="0.003" /><testcase classname="tests.communities.test_parent_community" name="test_invalid_set_parent_community_with_random_object" time="0.003" /><testcase classname="tests.communities.test_parent_community" name="test_parent_community_dereferencing" time="0.145"><failure message="sqlalchemy.orm.exc.StaleDataError: Version id '3' on merged state &lt;CommunityMetadata at 0x7fb0fb48d7c0&gt; does not match existing version '5'. Leave the version attribute unset when merging to update the most recent version.">community_service = &lt;invenio_communities.communities.services.service.CommunityService object at 0x7fb0fc71b6b0&gt;
parent_community = {'$schema': 'local://communities/communities-v1.0.0.json', 'files': {'enabled': True}, 'metadata': {'title': 'My Commu...members_visibility': 'public', 'member_policy': 'open', 'record_submission_policy': 'open', 'review_policy': 'closed'}}
child_community = {'$schema': 'local://communities/communities-v1.0.0.json', 'files': {'enabled': True}, 'metadata': {'title': 'My Commu...ecord_submission_policy': 'open', 'review_policy': 'closed'}, 'parent': {'id': '39dbdf4e-e0e3-416a-bf43-6054510afaab'}}
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    def test_parent_community_dereferencing(
        community_service, parent_community, child_community, db
    ):
        child_community.parent = parent_community
    
        assert child_community.parent == parent_community
    
&gt;       child_community.commit()

tests/communities/test_parent_community.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_records/api.py:461: in commit
    db.session.merge(self.model)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/scoping.py:1553: in merge
    return self._proxied.merge(instance, load=load, options=options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3945: in merge
    return self._merge(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.orm.session.PytestInvenioSession object at 0x7fb0fbab2c00&gt;
state = &lt;sqlalchemy.orm.state.InstanceState object at 0x7fb0fc5f4470&gt;
state_dict = {'_sa_instance_state': &lt;sqlalchemy.orm.state.InstanceState object at 0x7fb0fc5f4470&gt;, 'bucket_id': UUID('56d55ee1-c519...tetime.datetime(2025, 11, 18, 18, 49, 2, 376822), 'deletion_status': &lt;CommunityDeletionStatusEnum.PUBLISHED: 'P'&gt;, ...}

    def _merge(
        self,
        state: InstanceState[_O],
        state_dict: _InstanceDict,
        *,
        options: Optional[Sequence[ORMOption]] = None,
        load: bool,
        _recursive: Dict[Any, object],
        _resolve_conflict_map: Dict[_IdentityKeyType[Any], object],
    ) -&gt; _O:
        mapper: Mapper[_O] = _state_mapper(state)
        if state in _recursive:
            return cast(_O, _recursive[state])
    
        new_instance = False
        key = state.key
    
        merged: Optional[_O]
    
        if key is None:
            if state in self._new:
                util.warn(
                    "Instance %s is already pending in this Session yet is "
                    "being merged again; this is probably not what you want "
                    "to do" % state_str(state)
                )
    
            if not load:
                raise sa_exc.InvalidRequestError(
                    "merge() with load=False option does not support "
                    "objects transient (i.e. unpersisted) objects.  flush() "
                    "all changes on mapped instances before merging with "
                    "load=False."
                )
            key = mapper._identity_key_from_state(state)
            key_is_persistent = LoaderCallableStatus.NEVER_SET not in key[
                1
            ] and (
                not _none_set.intersection(key[1])
                or (
                    mapper.allow_partial_pks
                    and not _none_set.issuperset(key[1])
                )
            )
        else:
            key_is_persistent = True
    
        merged = self.identity_map.get(key)
    
        if merged is None:
            if key_is_persistent and key in _resolve_conflict_map:
                merged = cast(_O, _resolve_conflict_map[key])
    
            elif not load:
                if state.modified:
                    raise sa_exc.InvalidRequestError(
                        "merge() with load=False option does not support "
                        "objects marked as 'dirty'.  flush() all changes on "
                        "mapped instances before merging with load=False."
                    )
                merged = mapper.class_manager.new_instance()
                merged_state = attributes.instance_state(merged)
                merged_state.key = key
                self._update_impl(merged_state)
                new_instance = True
    
            elif key_is_persistent:
                merged = self.get(
                    mapper.class_,
                    key[1],
                    identity_token=key[2],
                    options=options,
                )
    
        if merged is None:
            merged = mapper.class_manager.new_instance()
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)
            new_instance = True
            self._save_or_update_state(merged_state)
        else:
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)
    
        _recursive[state] = merged
        _resolve_conflict_map[key] = merged
    
        # check that we didn't just pull the exact same
        # state out.
        if state is not merged_state:
            # version check if applicable
            if mapper.version_id_col is not None:
                existing_version = mapper._get_state_attr_by_column(
                    state,
                    state_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
    
                merged_version = mapper._get_state_attr_by_column(
                    merged_state,
                    merged_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
    
                if (
                    existing_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and merged_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and existing_version != merged_version
                ):
&gt;                   raise exc.StaleDataError(
                        "Version id '%s' on merged state %s "
                        "does not match existing version '%s'. "
                        "Leave the version attribute unset when "
                        "merging to update the most recent version."
                        % (
                            existing_version,
                            state_str(merged_state),
                            merged_version,
                        )
                    )
E                   sqlalchemy.orm.exc.StaleDataError: Version id '3' on merged state &lt;CommunityMetadata at 0x7fb0fb48d7c0&gt; does not match existing version '5'. Leave the version attribute unset when merging to update the most recent version.

.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4069: StaleDataError</failure></testcase><testcase classname="tests.communities.test_parent_community" name="test_parent_community_dereferencing" time="0.922"><error message="failed on teardown with &quot;sqlalchemy.orm.exc.StaleDataError: UPDATE statement on table 'communities_metadata' expected to update 1 row(s); 0 were matched.&quot;">database = &lt;SQLAlchemy&gt;

    @pytest.yield_fixture(scope="module")
    def location(database):
        """Creates a simple default location for a test.
    
        Scope: function
    
        Use this fixture if your test requires a `files location &lt;https://invenio-
        files-rest.readthedocs.io/en/latest/api.html#invenio_files_rest.models.
        Location&gt;`_. The location will be a default location with the name
        ``pytest-location``.
        """
        from invenio_files_rest.models import Location
    
        uri = tempfile.mkdtemp()
        location_obj = Location(name="pytest-location", uri=uri, default=True)
    
        database.session.add(location_obj)
        database.session.commit()
    
        yield location_obj
    
&gt;       shutil.rmtree(location_obj.uri)
                      ^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/pytest_invenio/fixtures.py:766: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/sqlalchemy/orm/attributes.py:569: in __get__
    return self.impl.get(state, dict_)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/attributes.py:1096: in get
    value = self._fire_loader_callables(state, key, passive)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/attributes.py:1126: in _fire_loader_callables
    return state._load_expired(state, passive)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:803: in _load_expired
    self.manager.expired_attribute_loader(self, toload, passive)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1674: in load_scalar_attributes
    result = load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:695: in load_on_pk_identity
    session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2228: in _execute_internal
    ) = compile_state_cls.orm_pre_session_exec(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:577: in orm_pre_session_exec
    session._autoflush()
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3040: in _autoflush
    self.flush()
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4331: in flush
    self._flush(objects)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4427: in _flush
    flush_context.execute()
.venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:85: in save_obj
    _emit_update_statements(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = &lt;Mapper at 0x7fb10059e0f0; CommunityMetadata&gt;
uowtransaction = &lt;sqlalchemy.orm.unitofwork.UOWTransaction object at 0x7fb0fb9f6660&gt;
mapper = &lt;Mapper at 0x7fb10059e0f0; CommunityMetadata&gt;
table = Table('communities_metadata', MetaData(), Column('slug', String(length=255), table=&lt;communities_metadata&gt;), Column('bu...s_metadata&gt;, nullable=False, default=CallableColumnDefault(&lt;function datetime.utcnow at 0x7fb104505bc0&gt;)), schema=None)
update = &lt;generator object _collect_update_commands at 0x7fb0fdc7e980&gt;

    def _emit_update_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        update,
        *,
        bookkeeping=True,
        use_orm_update_stmt=None,
        enable_check_rowcount=True,
    ):
        """Emit UPDATE statements corresponding to value lists collected
        by _collect_update_commands()."""
    
        needs_version_id = (
            mapper.version_id_col is not None
            and mapper.version_id_col in mapper._cols_by_table[table]
        )
    
        execution_options = {"compiled_cache": base_mapper._compiled_cache}
    
        def update_stmt(existing_stmt=None):
            clauses = BooleanClauseList._construct_raw(operators.and_)
    
            for col in mapper._pks_by_table[table]:
                clauses._append_inplace(
                    col == sql.bindparam(col._label, type_=col.type)
                )
    
            if needs_version_id:
                clauses._append_inplace(
                    mapper.version_id_col
                    == sql.bindparam(
                        mapper.version_id_col._label,
                        type_=mapper.version_id_col.type,
                    )
                )
    
            if existing_stmt is not None:
                stmt = existing_stmt.where(clauses)
            else:
                stmt = table.update().where(clauses)
            return stmt
    
        if use_orm_update_stmt is not None:
            cached_stmt = update_stmt(use_orm_update_stmt)
    
        else:
            cached_stmt = base_mapper._memo(("update", table), update_stmt)
    
        for (
            (connection, paramkeys, hasvalue, has_all_defaults, has_all_pks),
            records,
        ) in groupby(
            update,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # set of parameter keys
                bool(rec[5]),  # whether or not we have "value" parameters
                rec[6],  # has_all_defaults
                rec[7],  # has all pks
            ),
        ):
            rows = 0
            records = list(records)
    
            statement = cached_stmt
    
            if use_orm_update_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_update_table": table,
                        "_emit_update_mapper": mapper,
                    }
                )
    
            return_defaults = False
    
            if not has_all_pks:
                statement = statement.return_defaults(*mapper._pks_by_table[table])
                return_defaults = True
    
            if (
                bookkeeping
                and not has_all_defaults
                and mapper.base_mapper.eager_defaults is True
                # change as of #8889 - if RETURNING is not going to be used anyway,
                # (applies to MySQL, MariaDB which lack UPDATE RETURNING) ensure
                # we can do an executemany UPDATE which is more efficient
                and table.implicit_returning
                and connection.dialect.update_returning
            ):
                statement = statement.return_defaults(
                    *mapper._server_onupdate_default_cols[table]
                )
                return_defaults = True
    
            if mapper._version_id_has_server_side_value:
                statement = statement.return_defaults(mapper.version_id_col)
                return_defaults = True
    
            assert_singlerow = connection.dialect.supports_sane_rowcount
    
            assert_multirow = (
                assert_singlerow
                and connection.dialect.supports_sane_multi_rowcount
            )
    
            # change as of #8889 - if RETURNING is not going to be used anyway,
            # (applies to MySQL, MariaDB which lack UPDATE RETURNING) ensure
            # we can do an executemany UPDATE which is more efficient
            allow_executemany = not return_defaults and not needs_version_id
    
            if hasvalue:
                for (
                    state,
                    state_dict,
                    params,
                    mapper,
                    connection,
                    value_params,
                    has_all_defaults,
                    has_all_pks,
                ) in records:
                    c = connection.execute(
                        statement.values(value_params),
                        params,
                        execution_options=execution_options,
                    )
                    if bookkeeping:
                        _postfetch(
                            mapper,
                            uowtransaction,
                            table,
                            state,
                            state_dict,
                            c,
                            c.context.compiled_parameters[0],
                            value_params,
                            True,
                            c.returned_defaults,
                        )
                    rows += c.rowcount
                    check_rowcount = enable_check_rowcount and assert_singlerow
            else:
                if not allow_executemany:
                    check_rowcount = enable_check_rowcount and assert_singlerow
                    for (
                        state,
                        state_dict,
                        params,
                        mapper,
                        connection,
                        value_params,
                        has_all_defaults,
                        has_all_pks,
                    ) in records:
                        c = connection.execute(
                            statement, params, execution_options=execution_options
                        )
    
                        # TODO: why with bookkeeping=False?
                        if bookkeeping:
                            _postfetch(
                                mapper,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                c,
                                c.context.compiled_parameters[0],
                                value_params,
                                True,
                                c.returned_defaults,
                            )
                        rows += c.rowcount
                else:
                    multiparams = [rec[2] for rec in records]
    
                    check_rowcount = enable_check_rowcount and (
                        assert_multirow
                        or (assert_singlerow and len(multiparams) == 1)
                    )
    
                    c = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    rows += c.rowcount
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper,
                        connection,
                        value_params,
                        has_all_defaults,
                        has_all_pks,
                    ) in records:
                        if bookkeeping:
                            _postfetch(
                                mapper,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                c,
                                c.context.compiled_parameters[0],
                                value_params,
                                True,
                                (
                                    c.returned_defaults
                                    if not c.context.executemany
                                    else None
                                ),
                            )
    
            if check_rowcount:
                if rows != len(records):
&gt;                   raise orm_exc.StaleDataError(
                        "UPDATE statement on table '%s' expected to "
                        "update %d row(s); %d were matched."
                        % (table.description, len(records), rows)
                    )
E                   sqlalchemy.orm.exc.StaleDataError: UPDATE statement on table 'communities_metadata' expected to update 1 row(s); 0 were matched.

.venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:948: StaleDataError</error></testcase><testcase classname="tests.communities.test_permissions" name="ISORT" time="0.016" /><testcase classname="tests.communities.test_permissions" name="black" time="0.172" /><testcase classname="tests.communities.test_permissions" name="test_can_request_membership" time="3.922" /><testcase classname="tests.communities.test_relations_organizations" name="ISORT" time="0.028" /><testcase classname="tests.communities.test_relations_organizations" name="black" time="0.195" /><testcase classname="tests.communities.test_relations_organizations" name="test_organizations_field" time="2.544" /><testcase classname="tests.communities.test_relations_organizations" name="test_community_organizations_validation" time="1.064" /><testcase classname="tests.communities.test_relations_organizations" name="test_community_organizations_with_multiple_organizations" time="0.595" /><testcase classname="tests.communities.test_relations_organizations" name="test_community_organizations_with_name_cleanup_validation" time="0.493" /><testcase classname="tests.communities.test_relations_organizations" name="test_community_organizations_indexing" time="0.645" /><testcase classname="tests.communities.test_relations_organizations" name="test_community_organizations_invalid" time="1.019" /><testcase classname="tests.communities.test_relations_types" name="ISORT" time="0.020" /><testcase classname="tests.communities.test_relations_types" name="black" time="0.182" /><testcase classname="tests.communities.test_relations_types" name="test_valid_community_types[organization-organization]" time="3.131" /><testcase classname="tests.communities.test_relations_types" name="test_valid_community_types[event-event]" time="1.036" /><testcase classname="tests.communities.test_relations_types" name="test_valid_community_types[topic-topic]" time="0.579" /><testcase classname="tests.communities.test_relations_types" name="test_valid_community_types[project-project]" time="0.580" /><testcase classname="tests.communities.test_relations_types" name="test_invalid_community_type" time="0.564" /><testcase classname="tests.communities.test_relations_types" name="test_organizations_field" time="0.472" /><testcase classname="tests.communities.test_resources" name="ISORT" time="0.145" /><testcase classname="tests.communities.test_resources" name="black" time="0.386" /><testcase classname="tests.communities.test_resources" name="test_simple_flow" time="5.225" /><testcase classname="tests.communities.test_resources" name="test_post_schema_validation" time="2.105" /><testcase classname="tests.communities.test_resources" name="test_post_metadata_schema_validation" time="2.347" /><testcase classname="tests.communities.test_resources" name="test_post_community_with_existing_id" time="2.595" /><testcase classname="tests.communities.test_resources" name="test_post_community_with_deleted_id" time="2.049" /><testcase classname="tests.communities.test_resources" name="test_post_self_links" time="1.992" /><testcase classname="tests.communities.test_resources" name="test_simple_search_response" time="5.913" /><testcase classname="tests.communities.test_resources" name="test_simple_get_response" time="2.243" /><testcase classname="tests.communities.test_resources" name="test_simple_put_response" time="2.323" /><testcase classname="tests.communities.test_resources" name="test_update_renamed_record" time="1.969" /><testcase classname="tests.communities.test_resources" name="test_simple_delete_response" time="2.552" /><testcase classname="tests.communities.test_resources" name="test_logo_flow" time="2.162" /><testcase classname="tests.communities.test_resources" name="test_logo_max_content_length" time="1.919" /><testcase classname="tests.communities.test_resources" name="test_invalid_community_ids_create" time="1.719" /><testcase classname="tests.communities.test_resources" name="test_invalid_community_ids" time="1.988" /><testcase classname="tests.communities.test_resources" name="test_featured_communities" time="2.083" /><testcase classname="tests.communities.test_resources" name="test_simple_flow_restricted_community" time="0.541" /><testcase classname="tests.communities.test_resources" name="test_permissions_modify_community_visibility" time="0.586" /><testcase classname="tests.communities.test_resources" name="test_permissions_modify_community_to_public" time="0.921" /><testcase classname="tests.communities.test_services" name="ISORT" time="0.125" /><testcase classname="tests.communities.test_services" name="black" time="0.331" /><testcase classname="tests.communities.test_services" name="test_search_featured" time="5.089" /><testcase classname="tests.communities.test_services" name="test_reindex_featured_entries_task" time="3.995" /><testcase classname="tests.communities.test_services" name="test_create_featured" time="0.223" /><testcase classname="tests.communities.test_services" name="test_get_featured" time="0.170" /><testcase classname="tests.communities.test_services" name="test_delete_featured" time="0.232" /><testcase classname="tests.communities.test_services" name="test_update_featured" time="0.228" /><testcase classname="tests.communities.test_services" name="test_cleanup_pre_search" time="1.576" /><testcase classname="tests.communities.test_services" name="test_search_user" time="2.640" /><testcase classname="tests.communities.test_services" name="test_search_community_requests" time="1.762" /><testcase classname="tests.communities.test_services" name="test_community_deletion" time="0.178" /><testcase classname="tests.communities.test_services" name="test_invalid_community_deletion_workflows" time="0.128" /><testcase classname="tests.communities.test_services" name="test_get_cached_community_slug" time="1.729" /><testcase classname="tests.communities.test_services" name="test_theme_updates" time="2.245" /><testcase classname="tests.communities.test_services" name="test_children_updates" time="1.776" /><testcase classname="tests.communities.test_services" name="test_parent_create" time="0.167" /><testcase classname="tests.communities.test_services" name="test_parent_update" time="0.854" /><testcase classname="tests.communities.test_services" name="test_parent_remove" time="0.250" /><testcase classname="tests.communities.test_services" name="test_update_parent_community_not_exists" time="0.100" /><testcase classname="tests.communities.test_services" name="test_parent_update_parent_children_not_allowed" time="0.163" /><testcase classname="tests.communities.test_services" name="test_parent_update_child_children_are_allowed" time="0.271" /><testcase classname="tests.communities.test_services" name="test_bulk_update_parent" time="0.441" /><testcase classname="tests.communities.test_services" name="test_bulk_update_parent_overwrite" time="0.722" /><testcase classname="tests.communities.test_subcommunities" name="ISORT" time="0.072" /><testcase classname="tests.communities.test_subcommunities" name="black" time="0.239" /><testcase classname="tests.communities.test_subcommunities" name="test_service_join_already_existing" time="3.369" /><testcase classname="tests.communities.test_subcommunities" name="test_service_join_with_new_community" time="0.731" /><testcase classname="tests.communities.test_subcommunities" name="test_service_join_permissions" time="0.505" /><testcase classname="tests.communities.test_subcommunities" name="test_subcommunity_simple_flow" time="1.071" /><testcase classname="tests.communities.test_subcommunities" name="test_subcommunity_existing_child_flow" time="1.304" /><testcase classname="tests.communities.test_tombstone" name="ISORT" time="0.031" /><testcase classname="tests.communities.test_tombstone" name="black" time="0.189" /><testcase classname="tests.communities.test_tombstone" name="test_tombstone_creation" time="2.160" /><testcase classname="tests.communities.test_tombstone" name="test_tombstone_invalid_removed_by" time="0.002" /><testcase classname="tests.communities.test_tombstone" name="test_tombstone_valid_removed_by" time="0.201" /><testcase classname="tests.communities.test_tombstone" name="test_community_deletion_status_default" time="0.002" /><testcase classname="tests.communities.test_tombstone" name="test_community_deletion_status_valid_values" time="0.002" /><testcase classname="tests.communities.test_tombstone" name="test_community_deletion_status_invalid_values" time="0.002" /><testcase classname="tests.communities.test_tombstone" name="test_community_deletion_status" time="0.396" /><testcase classname="tests.communities.test_ui" name="ISORT" time="0.019" /><testcase classname="tests.communities.test_ui" name="black" time="0.170" /><testcase classname="tests.communities.test_ui" name="test_template_loader" time="2.507" /><testcase classname="tests.communities.tests_views" name="PYDOCSTYLE" time="0.009" /><testcase classname="tests.communities.tests_views" name="ISORT" time="0.022" /><testcase classname="tests.communities.tests_views" name="black" time="0.176" /><testcase classname="tests.conftest" name="PYDOCSTYLE" time="0.049" /><testcase classname="tests.conftest" name="ISORT" time="0.110" /><testcase classname="tests.conftest" name="black" time="0.268" /><testcase classname="tests.members.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="tests.members.__init__" name="ISORT" time="0.004" /><testcase classname="tests.members.__init__" name="black" time="0.159" /><testcase classname="tests.members.conftest" name="PYDOCSTYLE" time="0.011" /><testcase classname="tests.members.conftest" name="ISORT" time="0.023" /><testcase classname="tests.members.conftest" name="black" time="0.179" /><testcase classname="tests.members.test_members_components" name="ISORT" time="0.031" /><testcase classname="tests.members.test_members_components" name="black" time="0.194" /><testcase classname="tests.members.test_members_components" name="test_accept_invite_cache_clear" time="5.475" /><testcase classname="tests.members.test_members_components" name="test_member_delete_cache_clear" time="2.378" /><testcase classname="tests.members.test_members_components" name="test_member_add_cache_clear" time="1.642" /><testcase classname="tests.members.test_members_components" name="test_member_update_cache_clear" time="1.732" /><testcase classname="tests.members.test_members_components" name="test_group_actions_cache_clear" time="2.319" /><testcase classname="tests.members.test_members_no_groups" name="ISORT" time="0.015" /><testcase classname="tests.members.test_members_no_groups" name="black" time="0.172" /><testcase classname="tests.members.test_members_no_groups" name="test_invite_member_with_groups_disabled" time="3.309" /><testcase classname="tests.members.test_members_no_groups" name="test_add_member_with_groups_disabled[owner-owner]" time="0.407" /><testcase classname="tests.members.test_members_no_groups" name="test_add_member_with_groups_disabled[owner-manager]" time="0.385" /><testcase classname="tests.members.test_members_no_groups" name="test_add_member_with_groups_disabled[owner-curator]" time="0.402" /><testcase classname="tests.members.test_members_no_groups" name="test_add_member_with_groups_disabled[owner-reader]" time="0.385" /><testcase classname="tests.members.test_members_no_groups" name="test_add_member_with_groups_disabled[manager-manager]" time="0.410" /><testcase classname="tests.members.test_members_no_groups" name="test_add_member_with_groups_disabled[manager-curator]" time="0.399" /><testcase classname="tests.members.test_members_no_groups" name="test_add_member_with_groups_disabled[manager-reader]" time="1.560" /><testcase classname="tests.members.test_members_notifications" name="ISORT" time="0.058" /><testcase classname="tests.members.test_members_notifications" name="black" time="0.229" /><testcase classname="tests.members.test_members_notifications" name="test_community_invitation_submit_notification" time="4.582" /><testcase classname="tests.members.test_members_notifications" name="test_community_invitation_accept_notification" time="1.669" /><testcase classname="tests.members.test_members_notifications" name="test_community_invitation_cancel_notification" time="1.227" /><testcase classname="tests.members.test_members_notifications" name="test_community_invitation_decline_notification" time="1.581" /><testcase classname="tests.members.test_members_notifications" name="test_community_invitation_expire_notification" time="1.985" /><testcase classname="tests.members.test_members_resource" name="ISORT" time="0.066" /><testcase classname="tests.members.test_members_resource" name="black" time="0.245" /><testcase classname="tests.members.test_members_resource" name="test_add" time="3.014" /><testcase classname="tests.members.test_members_resource" name="test_add_denied" time="0.171" /><testcase classname="tests.members.test_members_resource" name="test_add_bad_data" time="0.044" /><testcase classname="tests.members.test_members_resource" name="test_add_invalid_member" time="0.059" /><testcase classname="tests.members.test_members_resource" name="test_add_duplicate" time="0.400" /><testcase classname="tests.members.test_members_resource" name="test_invite" time="0.880" /><testcase classname="tests.members.test_members_resource" name="test_invite_deny" time="0.344" /><testcase classname="tests.members.test_members_resource" name="test_update" time="0.416" /><testcase classname="tests.members.test_members_resource" name="test_update_invite" time="0.690" /><testcase classname="tests.members.test_members_resource" name="test_delete" time="1.334" /><testcase classname="tests.members.test_members_resource" name="test_search" time="0.973" /><testcase classname="tests.members.test_members_resource" name="test_search_public" time="0.673" /><testcase classname="tests.members.test_members_resource" name="test_search_invitation" time="1.028" /><testcase classname="tests.members.test_members_resource" name="test_post_membership_requests" time="0.674" /><testcase classname="tests.members.test_members_resource" name="test_put_membership_requests" time="0.302" /><testcase classname="tests.members.test_members_resource" name="test_error_handling_for_membership_requests" time="0.303" /><testcase classname="tests.members.test_members_resource" name="test_get_membership_requests" time="0.357" /><testcase classname="tests.members.test_members_services" name="ISORT" time="0.190" /><testcase classname="tests.members.test_members_services" name="black" time="0.405" /><testcase classname="tests.members.test_members_services" name="test_add_allowed[owner-owner]" time="2.996" /><testcase classname="tests.members.test_members_services" name="test_add_allowed[owner-manager]" time="0.438" /><testcase classname="tests.members.test_members_services" name="test_add_allowed[owner-curator]" time="0.417" /><testcase classname="tests.members.test_members_services" name="test_add_allowed[owner-reader]" time="0.391" /><testcase classname="tests.members.test_members_services" name="test_add_allowed[manager-manager]" time="0.410" /><testcase classname="tests.members.test_members_services" name="test_add_allowed[manager-curator]" time="0.387" /><testcase classname="tests.members.test_members_services" name="test_add_allowed[manager-reader]" time="0.409" /><testcase classname="tests.members.test_members_services" name="test_add_denied[manager-owner]" time="0.366" /><testcase classname="tests.members.test_members_services" name="test_add_denied[curator-owner]" time="1.489" /><testcase classname="tests.members.test_members_services" name="test_add_denied[curator-manager]" time="0.383" /><testcase classname="tests.members.test_members_services" name="test_add_denied[curator-curator]" time="0.361" /><testcase classname="tests.members.test_members_services" name="test_add_denied[curator-reader]" time="0.367" /><testcase classname="tests.members.test_members_services" name="test_add_denied[reader-owner]" time="0.397" /><testcase classname="tests.members.test_members_services" name="test_add_denied[reader-manager]" time="0.363" /><testcase classname="tests.members.test_members_services" name="test_add_denied[reader-curator]" time="0.365" /><testcase classname="tests.members.test_members_services" name="test_add_denied[reader-reader]" time="0.383" /><testcase classname="tests.members.test_members_services" name="test_add_duplicate" time="0.353" /><testcase classname="tests.members.test_members_services" name="test_add_invalid_member_type" time="0.439" /><testcase classname="tests.members.test_members_services" name="test_add_visible_property" time="0.344" /><testcase classname="tests.members.test_members_services" name="test_add_invalid_data" time="0.331" /><testcase classname="tests.members.test_members_services" name="test_invite" time="0.745" /><testcase classname="tests.members.test_members_services" name="test_invite_group_denied" time="0.342" /><testcase classname="tests.members.test_members_services" name="test_invite_already_member" time="2.516" /><testcase classname="tests.members.test_members_services" name="test_invite_with_message" time="0.678" /><testcase classname="tests.members.test_members_services" name="test_invite_view_request" time="1.014" /><testcase classname="tests.members.test_members_services" name="test_search_members" time="2.143" /><testcase classname="tests.members.test_members_services" name="test_scan_members" time="0.638" /><testcase classname="tests.members.test_members_services" name="test_search_public_members" time="0.790" /><testcase classname="tests.members.test_members_services" name="test_search_members_restricted" time="0.695" /><testcase classname="tests.members.test_members_services" name="test_search_members_visibility_restricted" time="0.695" /><testcase classname="tests.members.test_members_services" name="test_search_members_restricted_as_group" time="0.711" /><testcase classname="tests.members.test_members_services" name="test_read_memberships" time="0.688" /><testcase classname="tests.members.test_members_services" name="test_search_invitations" time="2.001" /><testcase classname="tests.members.test_members_services" name="test_invite_accept_flow" time="1.774" /><testcase classname="tests.members.test_members_services" name="test_invite_decline_flow" time="1.841" /><testcase classname="tests.members.test_members_services" name="test_invite_cancel_flow" time="1.421" /><testcase classname="tests.members.test_members_services" name="test_invite_actions_permissions" time="0.916" /><testcase classname="tests.members.test_members_services" name="test_leave_allowed[manager]" time="0.414" /><testcase classname="tests.members.test_members_services" name="test_leave_allowed[curator]" time="0.420" /><testcase classname="tests.members.test_members_services" name="test_leave_allowed[reader]" time="0.389" /><testcase classname="tests.members.test_members_services" name="test_leave_single_owner_denied" time="0.030" /><testcase classname="tests.members.test_members_services" name="test_leave_denied" time="0.656" /><testcase classname="tests.members.test_members_services" name="test_leave_owner_allowed" time="0.376"><error message="failed on teardown with &quot;RuntimeError: Could not delete any rows in this iteration due to foreign key cycles in tables: ['communities_members']&quot;">database = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;
db_session_options = {}

    @pytest.fixture(scope="function")
    def db(database, db_session_options):
        """Creates a new database session for a test.
    
        Scope: function
    
        You must use this fixture if your test connects to the database. The
        fixture will set a save point and rollback all changes performed during
        the test (this is much faster than recreating the entire database).
        """
        from flask_sqlalchemy.session import Session as FlaskSQLAlchemySession
    
        from pytest_invenio.database_tools import (
            purge_database_values,
            store_database_values,
        )
    
        class PytestInvenioSession(FlaskSQLAlchemySession):
            def get_bind(self, mapper=None, clause=None, bind=None, **kwargs):
                if self.bind:
                    return self.bind
                return super().get_bind(mapper=mapper, clause=clause, bind=bind, **kwargs)
    
            def rollback(self) -&gt; None:
                if self._transaction is None:
                    pass
                else:
                    self._transaction.rollback(_to_root=False)
    
        # the session.rollback() does not always clean everything, if the test
        # used db.session.commit() and has not cleaned up after itself. We can not
        # use nested transactions because a lot of Invenio code would need to be updated
        # so that it is aware of the nested transaction concept. Instead, we store
        # the database values here and purge any new rows after the test.
        #
        # We do it in explicit connection to avoid issues in tests that drop all tables
        # (causes deadlock in alembic tests of invenio-pages on github actions, not
        # reproducible locally).
        print("MS PATCH Storing database values", file=sys.stderr, flush=True)
        with database.engine.connect() as connection:
            with connection.begin():
                stored_values = store_database_values(database.engine, connection)
        print("MS PATCH Stored", file=sys.stderr, flush=True)
    
        with database.engine.connect() as connection:
            with connection.begin():
    
                options = dict(
                    bind=connection,
                    binds={},
                    **db_session_options,
                    class_=PytestInvenioSession,
                )
    
                session = database._make_scoped_session(options=options)
    
                old_session = database.session
                database.session = session
    
                yield database
    
                print(
                    "MS PATCH Rollback and original connection close",
                    file=sys.stderr,
                    flush=True,
                )
                session.rollback()
                database.session = old_session
    
        print("MS PATCH Purging database changes", file=sys.stderr, flush=True)
        # use a brand new connection for the purge operation
        with database.engine.connect() as connection:
&gt;           purge_database_values(database.engine, connection, stored_values)

.venv/lib/python3.12/site-packages/pytest_invenio/fixtures.py:614: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/invenio)
conn = &lt;sqlalchemy.engine.base.Connection object at 0x7fb0ea4d0410&gt;
stored_values = {'access_actionsroles': [], 'access_actionssystemroles': [], 'access_actionsusers': [], 'accounts_domain_category': [], ...}

    def purge_database_values(engine, conn, stored_values):
        """Delete rows that are not in the stored values."""
    
        print("Purging database values", file=sys.stderr, flush=True)
        metadata = MetaData()
        metadata.reflect(engine)
    
        # Build a list of (table_name, delete_condition) tuples
        to_be_deleted = []
    
        for table_name, table in metadata.tables.items():
            stored_rows = stored_values.get(table_name, [])
    
            # Get primary key columns and foreign key columns
            pk_columns = [
                column
                for column in table.columns
                if column.primary_key or len(column.foreign_keys) &gt; 0
            ]
    
            if not pk_columns:
                logger.warning(f"Table {table_name} has no primary key. Skipping.")
                continue
    
            # Convert stored rows to a set of primary key tuples for fast lookup
            stored_pk_set = set(stored_rows)
    
            # create a select statement that would include only rows that are not present
            # in the stored values. It will be not (pk1 == val1 and pk2 == val2 and ...) and not (...)
            row_matcher_conditions = []
            for stored_pk in stored_pk_set:
                # Cast columns to string at database level for comparison
                condition = and_(
                    *(
                        func.cast(pk_col, String) == pk_val
                        for pk_col, pk_val in zip(pk_columns, stored_pk)
                    )
                )
                # negate the condition to match rows that are not equal
                row_matcher_conditions.append(~condition)
    
            if row_matcher_conditions:
                non_matching_condition = and_(*row_matcher_conditions)
                to_be_deleted.append(
                    (table_name, table, non_matching_condition, len(stored_pk_set))
                )
            else:
                # delete everything
                to_be_deleted.append((table_name, table, None, len(stored_pk_set)))
    
        # Try to delete rows with retry mechanism for foreign key constraints
        while to_be_deleted:
            failed_deletions = []
    
            for table_name, table, where_condition, expected_count in to_be_deleted:
                # Execute deletion in a transaction so that we can rollback on failure
                with conn.begin():
                    try:
                        delete_stmt = table.delete()
                        if where_condition is not None:
                            delete_stmt = delete_stmt.where(where_condition)
    
                        conn.execute(delete_stmt)
    
                        existing_count = conn.execute(
                            select(func.count()).select_from(table)
                        ).scalar()
                        conn.commit()
                        if existing_count != expected_count:
                            logger.warning(
                                "Not all rows deleted as expected, will try again."
                            )
                            failed_deletions.append(
                                (table_name, table, where_condition, expected_count)
                            )
                    except Exception:
                        # Rollback on failure and retry in next iteration
                        conn.rollback()
                        failed_deletions.append(
                            (table_name, table, where_condition, expected_count)
                        )
    
            if len(failed_deletions) == len(to_be_deleted):
                table_names = [table_name for table_name, _, _, _ in failed_deletions]
&gt;               raise RuntimeError(
                    f"Could not delete any rows in this iteration due to foreign key cycles in tables: {table_names}"
                )
E               RuntimeError: Could not delete any rows in this iteration due to foreign key cycles in tables: ['communities_members']

.venv/lib/python3.12/site-packages/pytest_invenio/database_tools.py:129: RuntimeError</error></testcase><testcase classname="tests.members.test_members_services" name="test_delete_denied[manager-owner]" time="1.698" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[curator-owner]" time="0.428" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[curator-manager]" time="0.445" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[curator-curator]" time="0.421" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[curator-reader]" time="0.439" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[reader-owner]" time="0.434" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[reader-manager]" time="0.442" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[reader-curator]" time="0.431" /><testcase classname="tests.members.test_members_services" name="test_delete_denied[reader-reader]" time="0.440" /><testcase classname="tests.members.test_members_services" name="test_delete_allowed[owner-owner]" time="0.531"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', role = 'owner'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,role",
        [
            ("owner", "owner"),
            ("owner", "manager"),
            ("owner", "curator"),
            ("owner", "reader"),
            ("manager", "manager"),
            ("manager", "curator"),
            ("manager", "reader"),
        ],
    )
    def test_delete_allowed(member_service, community, members, actor, role, new_user, db):
        """Test that the given roles CAN be removed by the actor."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again as the actor
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
        }
&gt;       member_service.delete(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0eae13e30&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_allowed[owner-manager]" time="0.446"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', role = 'manager'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,role",
        [
            ("owner", "owner"),
            ("owner", "manager"),
            ("owner", "curator"),
            ("owner", "reader"),
            ("manager", "manager"),
            ("manager", "curator"),
            ("manager", "reader"),
        ],
    )
    def test_delete_allowed(member_service, community, members, actor, role, new_user, db):
        """Test that the given roles CAN be removed by the actor."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again as the actor
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
        }
&gt;       member_service.delete(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0eac1d820&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_allowed[owner-curator]" time="0.474"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,role",
        [
            ("owner", "owner"),
            ("owner", "manager"),
            ("owner", "curator"),
            ("owner", "reader"),
            ("manager", "manager"),
            ("manager", "curator"),
            ("manager", "reader"),
        ],
    )
    def test_delete_allowed(member_service, community, members, actor, role, new_user, db):
        """Test that the given roles CAN be removed by the actor."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again as the actor
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
        }
&gt;       member_service.delete(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0eca8e780&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_allowed[owner-reader]" time="0.419"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', role = 'reader'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,role",
        [
            ("owner", "owner"),
            ("owner", "manager"),
            ("owner", "curator"),
            ("owner", "reader"),
            ("manager", "manager"),
            ("manager", "curator"),
            ("manager", "reader"),
        ],
    )
    def test_delete_allowed(member_service, community, members, actor, role, new_user, db):
        """Test that the given roles CAN be removed by the actor."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again as the actor
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
        }
&gt;       member_service.delete(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ed0312b0&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_allowed[manager-manager]" time="0.454"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', role = 'manager'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,role",
        [
            ("owner", "owner"),
            ("owner", "manager"),
            ("owner", "curator"),
            ("owner", "reader"),
            ("manager", "manager"),
            ("manager", "curator"),
            ("manager", "reader"),
        ],
    )
    def test_delete_allowed(member_service, community, members, actor, role, new_user, db):
        """Test that the given roles CAN be removed by the actor."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again as the actor
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
        }
&gt;       member_service.delete(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0eae45400&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_allowed[manager-curator]" time="0.473"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,role",
        [
            ("owner", "owner"),
            ("owner", "manager"),
            ("owner", "curator"),
            ("owner", "reader"),
            ("manager", "manager"),
            ("manager", "curator"),
            ("manager", "reader"),
        ],
    )
    def test_delete_allowed(member_service, community, members, actor, role, new_user, db):
        """Test that the given roles CAN be removed by the actor."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again as the actor
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
        }
&gt;       member_service.delete(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0eb316a80&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_allowed[manager-reader]" time="0.457"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', role = 'reader'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,role",
        [
            ("owner", "owner"),
            ("owner", "manager"),
            ("owner", "curator"),
            ("owner", "reader"),
            ("manager", "manager"),
            ("manager", "curator"),
            ("manager", "reader"),
        ],
    )
    def test_delete_allowed(member_service, community, members, actor, role, new_user, db):
        """Test that the given roles CAN be removed by the actor."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again as the actor
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
        }
&gt;       member_service.delete(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0e9df9f70&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_member_type_group" time="0.368"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
owner = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ebebeb40&gt;
group = &lt;Role it-dep&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    def test_delete_member_type_group(member_service, community, owner, group, db):
        """Groups can be removed."""
        # Add a new user with role
        data = {
            "members": [{"type": "group", "id": group.name}],
            "role": "reader",
        }
        member_service.add(system_identity, community._record.id, data)
        # Delete the member again
        data = {
            "members": [{"type": "group", "id": group.name}],
        }
&gt;       member_service.delete(owner.identity, community._record.id, data)

tests/members/test_members_services.py:747: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': 'it-dep', 'type': 'group'}]}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ecbfea20&gt;

    @unit_of_work()
    def delete(self, identity, community_id, data, uow=None):
        """Bulk delete."""
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to delete any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_delete",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.delete_schema.load(
            data,
            context={"identity": identity},
        )
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
    
        # Perform deletes (and check permissions)
        for m in members:
            self.require_permission(
                identity,
                "members_delete",
                record=community,
                member=m,
            )
            # Run components
            self.run_components(
                "members_delete",
                identity,
                record=m,
                community=community,
                errors=None,
                uow=uow,
            )
            uow.register(RecordDeleteOp(m, self.indexer, force=True))
    
        # Make sure we're not left owner-less
        if not self.record_cls.has_members(
            community_id, role=current_roles.owner_role.name
        ):
&gt;           raise ValidationError(
                _("A community must have at least one owner."),
            )
E           marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:661: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_delete_invalid_member" time="0.030" /><testcase classname="tests.members.test_members_services" name="test_selfupdate_denied" time="1.600" /><testcase classname="tests.members.test_members_services" name="test_selfupdate_role_denied[owner]" time="0.386"><failure message="invenio_communities.members.errors.InvalidMemberError">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner'

    @pytest.mark.parametrize(
        "actor",
        [
            "owner",
            "manager",
            "curator",
            "reader",
        ],
    )
    def test_selfupdate_role_denied(member_service, community, members, actor):
        """Nobody can change their own role."""
        user = members[actor]
        data = {
            "members": [{"type": "user", "id": str(user.id)}],
            "role": actor,
        }
&gt;       pytest.raises(
            ValidationError,
            member_service.update,
            user.identity,
            community._record.id,
            data,
        )

tests/members/test_members_services.py:804: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '1', 'type': 'user'}], 'role': Role(name='owner', title=l'Owner', description=l'Full administrativ...anage_roles=['owner', 'manager', 'curator', 'reader'], is_owner=True, can_manage=True, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0e9f689e0&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
&gt;           raise InvalidMemberError()
E           invenio_communities.members.errors.InvalidMemberError

invenio_communities/members/services/service.py:528: InvalidMemberError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_selfupdate_role_denied[manager]" time="0.384" /><testcase classname="tests.members.test_members_services" name="test_selfupdate_role_denied[curator]" time="0.413" /><testcase classname="tests.members.test_members_services" name="test_selfupdate_role_denied[reader]" time="0.379" /><testcase classname="tests.members.test_members_services" name="test_selfupdate_allow_visibility[owner]" time="0.375"><failure message="invenio_communities.members.errors.InvalidMemberError">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner'
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor",
        [
            "owner",
            "manager",
            "curator",
            "reader",
        ],
    )
    def test_selfupdate_allow_visibility(member_service, community, members, actor, db):
        """All + system identity can change their own visibility to true."""
        user = members[actor]
        data = {
            "members": [{"type": "user", "id": str(user.id)}],
            "visible": True,
        }
&gt;       member_service.update(user.identity, community._record.id, data)

tests/members/test_members_services.py:829: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '1', 'type': 'user'}], 'visible': True}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0eb25c110&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
&gt;           raise InvalidMemberError()
E           invenio_communities.members.errors.InvalidMemberError

invenio_communities/members/services/service.py:528: InvalidMemberError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_selfupdate_allow_visibility[manager]" time="0.449" /><testcase classname="tests.members.test_members_services" name="test_selfupdate_allow_visibility[curator]" time="0.432" /><testcase classname="tests.members.test_members_services" name="test_selfupdate_allow_visibility[reader]" time="0.459" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_denied[owner-owner]" time="0.416" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_denied[owner-manager]" time="0.425" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_denied[owner-curator]" time="0.440" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_denied[owner-reader]" time="0.416" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_denied[manager-manager]" time="0.433" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_denied[manager-curator]" time="0.411" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_denied[manager-reader]" time="0.435" /><testcase classname="tests.members.test_members_services" name="test_update_public_visibility_of_group_allowed" time="0.375" /><testcase classname="tests.members.test_members_services" name="test_update_hidden_visibility_allowed[owner-owner]" time="0.426" /><testcase classname="tests.members.test_members_services" name="test_update_hidden_visibility_allowed[owner-manager]" time="1.728" /><testcase classname="tests.members.test_members_services" name="test_update_hidden_visibility_allowed[owner-curator]" time="0.446" /><testcase classname="tests.members.test_members_services" name="test_update_hidden_visibility_allowed[owner-reader]" time="0.453" /><testcase classname="tests.members.test_members_services" name="test_update_hidden_visibility_allowed[manager-manager]" time="0.440" /><testcase classname="tests.members.test_members_services" name="test_update_hidden_visibility_allowed[manager-curator]" time="0.455" /><testcase classname="tests.members.test_members_services" name="test_update_hidden_visibility_allowed[manager-reader]" time="0.438" /><testcase classname="tests.members.test_members_services" name="test_update_role_allowed[owner-owner-reader]" time="0.462"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'owner', new_role = 'reader'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Update the member with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='reader', title=l'Reader', description=l'Can view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=False, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ea54f9b0&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_role_allowed[owner-manager-reader]" time="0.420"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'manager', new_role = 'reader'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Update the member with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='reader', title=l'Reader', description=l'Can view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=False, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0e9d97f80&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_role_allowed[owner-curator-manager]" time="0.439"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'curator', new_role = 'manager'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Update the member with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='manager', title=l'Manager', description=l'Can manage mem...', can_manage_roles=['manager', 'curator', 'reader'], is_owner=False, can_manage=True, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ea516030&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_role_allowed[owner-reader-curator]" time="0.419"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'reader', new_role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Update the member with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='curator', title=l'Curator', description=l'Can curate rec... and view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ed9406b0&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_role_allowed[manager-manager-curator]" time="0.425"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', initial_role = 'manager', new_role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Update the member with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='curator', title=l'Curator', description=l'Can curate rec... and view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ea514650&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_role_allowed[manager-curator-manager]" time="0.450"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', initial_role = 'curator', new_role = 'manager'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Update the member with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='manager', title=l'Manager', description=l'Can manage mem...', can_manage_roles=['manager', 'curator', 'reader'], is_owner=False, can_manage=True, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0f005fb00&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_role_allowed[manager-reader-curator]" time="0.422"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', initial_role = 'reader', new_role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Add a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.add(system_identity, community._record.id, data)
        # Update the member with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='curator', title=l'Curator', description=l'Can curate rec... and view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ee05bbf0&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_role_denied[manager-owner-reader]" time="0.434" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[curator-owner-reader]" time="0.412" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[curator-manager-curator]" time="0.433" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[curator-curator-manager]" time="0.420" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[curator-reader-owner]" time="1.764" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[reader-owner-owner]" time="0.446" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[reader-manager-manager]" time="0.424" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[reader-curator-curator]" time="0.435" /><testcase classname="tests.members.test_members_services" name="test_update_role_denied[reader-reader-manager]" time="0.415" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_allowed[owner-owner-reader]" time="0.728"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'owner', new_role = 'reader'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_invitation_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Invite a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.invite(members[actor].identity, community._record.id, data)
    
        # Update the invitation with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='reader', title=l'Reader', description=l'Can view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=False, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0eda1da00&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_allowed[owner-manager-reader]" time="0.687"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'manager', new_role = 'reader'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_invitation_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Invite a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.invite(members[actor].identity, community._record.id, data)
    
        # Update the invitation with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='reader', title=l'Reader', description=l'Can view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=False, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0e9ab78c0&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_allowed[owner-curator-manager]" time="0.718"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'curator', new_role = 'manager'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_invitation_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Invite a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.invite(members[actor].identity, community._record.id, data)
    
        # Update the invitation with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='manager', title=l'Manager', description=l'Can manage mem...', can_manage_roles=['manager', 'curator', 'reader'], is_owner=False, can_manage=True, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0e9b4d010&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_allowed[owner-reader-curator]" time="0.709"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'owner', initial_role = 'reader', new_role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_invitation_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Invite a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.invite(members[actor].identity, community._record.id, data)
    
        # Update the invitation with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="1" auth_type="None" provides={Need(method='system_role', value='any_user'), Need(method='id', value=1), ...44-136d3e25db6f', role='owner'), Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', role='owner')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='curator', title=l'Curator', description=l'Can curate rec... and view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0f0cdb320&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_allowed[manager-manager-curator]" time="0.700"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', initial_role = 'manager', new_role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_invitation_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Invite a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.invite(members[actor].identity, community._record.id, data)
    
        # Update the invitation with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='curator', title=l'Curator', description=l'Can curate rec... and view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0ebbb4980&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_allowed[manager-curator-manager]" time="0.684"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', initial_role = 'curator', new_role = 'manager'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_invitation_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Invite a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.invite(members[actor].identity, community._record.id, data)
    
        # Update the invitation with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='manager', title=l'Manager', description=l'Can manage mem...', can_manage_roles=['manager', 'curator', 'reader'], is_owner=False, can_manage=True, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0e91da270&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_allowed[manager-reader-curator]" time="0.685"><failure message="marshmallow.exceptions.ValidationError: A community must have at least one owner.">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
members = {'curator': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ede92ea0&gt;, 'manager': &lt;pytest_invenio.user.UserFixtur...er.UserFixtureBase object at 0x7fb0ebebeb40&gt;, 'reader': &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ed82f9b0&gt;}
actor = 'manager', initial_role = 'reader', new_role = 'curator'
new_user = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0eb328bc0&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    @pytest.mark.parametrize(
        "actor,initial_role,new_role",
        [
            ("owner", "owner", "reader"),
            ("owner", "manager", "reader"),
            ("owner", "curator", "manager"),
            ("owner", "reader", "curator"),
            ("manager", "manager", "curator"),
            ("manager", "curator", "manager"),
            ("manager", "reader", "curator"),
        ],
    )
    def test_update_invitation_role_allowed(
        member_service, community, members, actor, initial_role, new_role, new_user, db
    ):
        """Owners can change role of all, managers all but owners."""
        # Invite a new user with role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": initial_role,
        }
        member_service.invite(members[actor].identity, community._record.id, data)
    
        # Update the invitation with new role
        data = {
            "members": [{"type": "user", "id": str(new_user.id)}],
            "role": new_role,
        }
&gt;       member_service.update(members[actor].identity, community._record.id, data)

tests/members/test_members_services.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="2" auth_type="None" provides={Need(method='community', value='f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94', rol...='id', value=2), Need(method='system_role', value='any_user'), Need(method='system_role', value='authenticated_user')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': '5', 'type': 'user'}], 'role': Role(name='curator', title=l'Curator', description=l'Can curate rec... and view restricted records.', can_manage_roles=[], is_owner=False, can_manage=False, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0f0b81310&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
            raise InvalidMemberError()
        role = data.get("role")
        visible = data.get("visible")
    
        # Perform updates (and check permissions)
        for m in members:
            self._update(identity, community, m, role, visible, uow)
    
        # Make sure we're not left owner-less if a role was changed.
        if role is not None:
            if not self.record_cls.has_members(
                community_id, role=current_roles.owner_role.name
            ):
&gt;               raise ValidationError(
                    _("A community must have at least one owner."),
                )
E               marshmallow.exceptions.ValidationError: A community must have at least one owner.

invenio_communities/members/services/service.py:541: ValidationError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[manager-owner-reader]" time="0.702" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[curator-owner-reader]" time="0.669" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[curator-manager-curator]" time="0.686" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[curator-curator-manager]" time="0.656" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[curator-reader-owner]" time="0.688" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[reader-owner-owner]" time="2.009" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[reader-manager-manager]" time="0.671" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[reader-curator-curator]" time="0.662" /><testcase classname="tests.members.test_members_services" name="test_update_invitation_role_denied[reader-reader-manager]" time="0.658" /><testcase classname="tests.members.test_members_services" name="test_update_declined_invitation[decline]" time="7.360" /><testcase classname="tests.members.test_members_services" name="test_update_declined_invitation[cancel]" time="1.640" /><testcase classname="tests.members.test_members_services" name="test_update_declined_invitation[expire]" time="7.330" /><testcase classname="tests.members.test_members_services" name="test_update_role_must_have_owner" time="0.354"><failure message="invenio_communities.members.errors.InvalidMemberError">member_service = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
community = &lt;invenio_communities.communities.services.results.CommunityItem object at 0x7fb0ebd77a10&gt;
owner = &lt;pytest_invenio.user.UserFixtureBase object at 0x7fb0ebebeb40&gt;
group = &lt;Role it-dep&gt;
db = &lt;SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio&gt;

    def test_update_role_must_have_owner(member_service, community, owner, group, db):
        """There must always be at least one owner."""
        # Add an owner group
        data = {
            "members": [{"type": "group", "id": group.name}],
            "role": "owner",
        }
        member_service.add(system_identity, community._record.id, data)
    
        # Update the both owners with manager role using system_identity
        data = {
            "members": [
                {"type": "group", "id": group.name},
                {"type": "user", "id": str(owner.id)},
            ],
            "role": "manager",
        }
&gt;       pytest.raises(
            ValidationError,
            member_service.update,
            system_identity,
            community._record.id,
            data,
        )

tests/members/test_members_services.py:1100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/invenio_db/uow.py:251: in inner
    res = f(self, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;invenio_communities.members.services.service.MemberService object at 0x7fb0ec184ec0&gt;
identity = &lt;Identity id="system" auth_type="None" provides={Need(method='system_role', value='system_process')}&gt;
community_id = UUID('f9dc1a3c-f3e7-4683-b2d7-c9580a0a6c94')
data = {'members': [{'id': 'it-dep', 'type': 'group'}, {'id': '1', 'type': 'user'}], 'role': Role(name='manager', title=l'Man...', can_manage_roles=['manager', 'curator', 'reader'], is_owner=False, can_manage=True, can_curate=True, can_view=True)}
uow = &lt;invenio_db.uow.UnitOfWork object at 0x7fb0e9475820&gt;, refresh = False

    @unit_of_work()
    def update(self, identity, community_id, data, uow=None, refresh=False):
        """Bulk update.
    
        Used to update both active members and active invitations. Archived
        invitations cannot be updated.
        """
        community = self.community_cls.get_record(community_id)
    
        # Permission check - validates that:
        # - identity has permission to change any member at all (incl self)
        self.require_permission(
            identity,
            "members_bulk_update",
            record=community,
        )
    
        # Validate data (if there are errors, .load() raises)
        data, errors = self.update_schema.load(
            data,
            context={"identity": identity},
        )
    
        # Schema validates that role and/or visibility are defined.
        members = self.record_cls.get_members(community.id, members=data["members"])
        if len(members) != len(data["members"]):
&gt;           raise InvalidMemberError()
E           invenio_communities.members.errors.InvalidMemberError

invenio_communities/members/services/service.py:528: InvalidMemberError</failure></testcase><testcase classname="tests.members.test_members_services" name="test_update_invalid_data" time="0.069" /><testcase classname="tests.members.test_members_services" name="test_request_cancel_request_flow" time="2.076" /><testcase classname="tests.members.test_members_services" name="test_relation_update_propagation" time="1.150" /><testcase classname="tests.mock_module.__init__" name="PYDOCSTYLE" time="0.006" /><testcase classname="tests.mock_module.__init__" name="ISORT" time="0.012" /><testcase classname="tests.mock_module.__init__" name="black" time="0.163" /><testcase classname="tests.records.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="tests.records.__init__" name="ISORT" time="0.004" /><testcase classname="tests.records.__init__" name="black" time="0.159" /><testcase classname="tests.records.conftest" name="PYDOCSTYLE" time="0.007" /><testcase classname="tests.records.conftest" name="ISORT" time="0.014" /><testcase classname="tests.records.conftest" name="black" time="0.165" /><testcase classname="tests.records.mock_module.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="tests.records.mock_module.__init__" name="ISORT" time="0.003" /><testcase classname="tests.records.mock_module.__init__" name="black" time="0.158" /><testcase classname="tests.records.mock_module.api" name="PYDOCSTYLE" time="0.007" /><testcase classname="tests.records.mock_module.api" name="ISORT" time="0.011" /><testcase classname="tests.records.mock_module.api" name="black" time="0.163" /><testcase classname="tests.records.mock_module.jsonschemas.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="tests.records.mock_module.jsonschemas.__init__" name="ISORT" time="0.004" /><testcase classname="tests.records.mock_module.jsonschemas.__init__" name="black" time="0.157" /><testcase classname="tests.records.mock_module.mappings.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="tests.records.mock_module.mappings.__init__" name="ISORT" time="0.003" /><testcase classname="tests.records.mock_module.mappings.__init__" name="black" time="0.157" /><testcase classname="tests.records.mock_module.mappings.v6.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="tests.records.mock_module.mappings.v6.__init__" name="ISORT" time="0.003" /><testcase classname="tests.records.mock_module.mappings.v6.__init__" name="black" time="0.158" /><testcase classname="tests.records.mock_module.mappings.v7.__init__" name="PYDOCSTYLE" time="0.004" /><testcase classname="tests.records.mock_module.mappings.v7.__init__" name="ISORT" time="0.004" /><testcase classname="tests.records.mock_module.mappings.v7.__init__" name="black" time="0.158" /><testcase classname="tests.records.mock_module.models" name="PYDOCSTYLE" time="0.004" /><testcase classname="tests.records.mock_module.models" name="ISORT" time="0.010" /><testcase classname="tests.records.mock_module.models" name="black" time="0.160" /><testcase classname="tests.records.test_mockrecords_api" name="ISORT" time="0.031" /><testcase classname="tests.records.test_mockrecords_api" name="black" time="0.193" /><testcase classname="tests.records.test_mockrecords_api" name="test_record_create_empty" time="2.558" /><testcase classname="tests.records.test_mockrecords_api" name="test_get" time="0.333" /><testcase classname="tests.records.test_mockrecords_api" name="test_add" time="0.335" /><testcase classname="tests.records.test_mockrecords_api" name="test_add_existing" time="0.310" /><testcase classname="tests.records.test_mockrecords_api" name="test_len_contains" time="0.327" /><testcase classname="tests.records.test_mockrecords_api" name="test_remove" time="0.333" /><testcase classname="tests.records.test_mockrecords_api" name="test_iter" time="0.323" /><testcase classname="tests.records.test_mockrecords_api" name="test_ids" time="1.573" /><testcase classname="tests.records.test_mockrecords_api" name="test_change_default" time="0.331" /><testcase classname="tests.records.test_mockrecords_api" name="test_clear" time="0.318" /><testcase classname="tests.records.test_mockrecords_api" name="test_refresh" time="0.729" /><testcase classname="tests.test_notifications" name="ISORT" time="0.013" /><testcase classname="tests.test_notifications" name="black" time="0.166" /><testcase classname="tests.test_notifications" name="test_user_recipient_generator" time="4.414" /></testsuite></testsuites>